<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2022/06/29/sjms/"/>
    <url>/2022/06/29/sjms/</url>
    
    <content type="html"><![CDATA[<h3 id="1-2-工厂方法模式"><a href="#1-2-工厂方法模式" class="headerlink" title="1.2 工厂方法模式"></a>1.2 工厂方法模式</h3><p><strong>定义：</strong>定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</p><p>工厂方法存在的问题与解决方法：客户端需要创建类的具体的实例。简单来说就是用户要订纽约工厂的披萨，他必须去纽约工厂，想订伦敦工厂的披萨，必须去伦敦工厂。 当伦敦工厂和纽约工厂发生变化了，用户也要跟着变化，这无疑就增加了用户的操作复杂性。为了解决这一问题，我们可以把工厂类抽象为接口，用户只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，而不用根据产品去寻找不同的工厂，方便用户操作。这也就是我们接下来要说的抽象工厂模式。</p><h2 id="5-适配器模式"><a href="#5-适配器模式" class="headerlink" title="5 适配器模式"></a>5 适配器模式</h2><p><strong>定义：</strong> 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。</p><p><strong>主要分为三类：</strong>类的适配器模式、对象的适配器模式、接口的适配器模式。</p><h3 id="5-1-类适配器模式"><a href="#5-1-类适配器模式" class="headerlink" title="5.1 类适配器模式"></a>5.1 类适配器模式</h3><p>通过多重<strong>继承</strong>目标接口和被适配者类方式来实现适配</p><h3 id="5-2-对象适配器模式"><a href="#5-2-对象适配器模式" class="headerlink" title="5.2 对象适配器模式"></a>5.2 对象适配器模式</h3><p>对象适配器和类适配器使用了不同的方法实现适配，对象适配器使用组合，类适配器使用继承。</p><h3 id="5-3-接口适配器模式"><a href="#5-3-接口适配器模式" class="headerlink" title="5.3 接口适配器模式"></a>5.3 接口适配器模式</h3><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，<strong>它适用于一个接口不想使用其所有的方法的情况。</strong></p><p>7 代理模式<br>定义：代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。</p><p>举个例子来说明：假如说我现在想买一辆二手车，虽然我可以自己去找车源，做质量检测等一系列的车辆过户流程，但是这确实太浪费我得时间和精力了。我只是想买一辆车而已为什么我还要额外做这么多事呢？于是我就通过中介公司来买车，他们来给我找车源，帮我办理车辆过户流程，我只是负责选择自己喜欢的车，然后付钱就可以了。用图表示如下：</p><h3 id="1-3-抽象工厂模式"><a href="#1-3-抽象工厂模式" class="headerlink" title="1.3 抽象工厂模式"></a>1.3 抽象工厂模式</h3><p> <strong>定义：</strong>定义了一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类。</p><h2 id="25-单例模式"><a href="#25-单例模式" class="headerlink" title="25.单例模式"></a>25.单例模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p><strong>意图</strong>：保证一个类仅有一个实例，并提供一个访问它的全局访问点 </p><p><strong>主要解决</strong>：一个全局使用的类频繁地创建与销毁。</p><p>懒汉式，线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton2 instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton2</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton2 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton2</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>饿汉式，线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton3</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton3</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton3</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton3</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton3 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>&#125; <br><br></code></pre></td></tr></table></figure><p>双检锁&#x2F;双重校验锁 + volatile关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton7</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton7</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton7</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton7 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton7.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton7</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2022/06/29/jsjwl/"/>
    <url>/2022/06/29/jsjwl/</url>
    
    <content type="html"><![CDATA[<h2 id="OSI七层模型、TCP-x2F-IP概念模型、五层协议"><a href="#OSI七层模型、TCP-x2F-IP概念模型、五层协议" class="headerlink" title="OSI七层模型、TCP&#x2F;IP概念模型、五层协议"></a><strong>OSI七层模型、TCP&#x2F;IP概念模型、五层协议</strong></h2><p><img src="C:\Users\16966\AppData\Roaming\Typora\typora-user-images\image-20220326192322709.png" alt="image-20220326192322709"></p><p>物理层：建立、维护、断开物理连接。</p><p>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。</p><p>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。</p><p>运输层：定义传输数据的协议端口号，以及流控和差错校验。</p><p>会话层：建立、管理、终止会话。</p><p>表示层：数据的表示、安全、压缩。</p><p>应用层：网络服务与最终用户的一个接口。</p><hr><h2 id="三次握手、为什么是三次而不是更多、为什么不是两次"><a href="#三次握手、为什么是三次而不是更多、为什么不是两次" class="headerlink" title="三次握手、为什么是三次而不是更多、为什么不是两次"></a><strong>三次握手</strong>、<strong>为什么是三次而不是更多</strong>、<strong>为什么不是两次</strong></h2><p><strong>如果建立了连接，但是客户端突然出现了故障怎么办</strong></p><p>名词解释：</p><p>1、ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK&#x3D;1时,确认号才有效，当ACK&#x3D;0时，确认号无效，这时会要求重传数据，保证数据的完整性。</p><p>2、SYN 同步序列号，TCP建立连接时将这个位置1。</p><p>3、FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。</p><p><strong>TCP三次握手</strong></p><p>所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。</p><p>三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在socket编程中，客户端执行connect()时。将触发三次握手。</p><ul><li><p>第一次握手:<br>客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。</p></li><li><p>第二次握手:<br>服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。</p></li><li><p>第三次握手.<br>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1</p></li></ul><p>为啥不是两次：两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p><p><strong>SYN攻击</strong></p><p>  在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态.</p><p> Syn攻击就是 攻击客户端 在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直 至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</p><p> Syn攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.在Linux下可以如下命令检测是否被Syn攻击</p><p><strong>netstat -n -p TCP | grep SYN_RECV</strong></p><p>一般较新的TCP&#x2F;IP协议栈都对这一过程进行修正来防范Syn攻击，修改tcp协议实现。主要方法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等.</p><p>但是不能完全防范syn攻击。</p><h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a><strong>TCP 四次挥手</strong></h2><p>TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><p>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li></ul><p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p><p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><p>TIME_WAIT作用：</p><ul><li><em>保证连接正确关闭</em></li><li><em>防止旧连接的数据包</em></li></ul><p>TIME_WAIT过多有什么危害？</p><ul><li>第一是内存资源占用；</li><li>第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；</li></ul><blockquote><p>为什么挥手需要四次？</p></blockquote><p>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><hr><h2 id="httphttps两个协议区别"><a href="#httphttps两个协议区别" class="headerlink" title="httphttps两个协议区别"></a><strong>httphttps两个协议区别</strong></h2><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>​1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><p><img src="https://pics7.baidu.com/feed/bd3eb13533fa828b023f05c88bc2a83c960a5ae7.png?token=ecf00676134e552e7debc4b3cd7a4a1e" alt="img"></p><p><strong>HTTPS的优点</strong></p><p>　　尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><p>　　（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>　　（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><p>　　（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><p>　　（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><p><strong>HTTPS的缺点</strong></p><p>　　虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><p>　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p><p>　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p><p>　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p><p>　  （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p><p><strong>http切换到HTTPS</strong></p><p>　　如果需要将网站从http切换到https到底该如何实现呢？</p><p>   这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：<a href="http://www.baidu.com改为https//www.baidu.com">http://www.baidu.com改为https://www.baidu.com</a></p><p>　　BTW，这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将<a href="http://www.baidu.com改为//www.baidu.com%E3%80%82%E7%84%B6%E5%90%8E%E5%BD%93%E7%94%A8%E6%88%B7%E4%BB%8Ehttp%E7%9A%84%E5%85%A5%E5%8F%A3%E8%BF%9B%E5%85%A5%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%E6%97%B6%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%B0%B1%E6%98%AFhttp%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%94%A8%E6%88%B7%E6%98%AF%E4%BB%8Ehttps%E7%9A%84%E5%85%A5%E5%8F%A3%E8%BF%9B%E5%85%A5%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%8D%B3%E4%BD%BFhttps%E7%9A%84%E3%80%82">http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。</a></p><h2 id="Http请求过程"><a href="#Http请求过程" class="headerlink" title="Http请求过程"></a>Http请求过程</h2><p>Http请求过程客户端进行DNS域名解析，得到对应的IP地址</p><p>根据这个IP，找到对应的服务器建立连接（三次握手）</p><p>建立TCP连接后发起HTTP请求（一个完整的http请求报文）</p><p>服务器响应HTTP请求，客户端得到html代码</p><p>客户端解析html代码，用html代码中的资源(如js,css,图片等等)渲染页面。</p><p>服务器关闭TCP连接（四次挥手）</p><h2 id="Https工作流程："><a href="#Https工作流程：" class="headerlink" title="Https工作流程："></a>Https工作流程：</h2><p>Https工作流程客户端发起Https请求，连接到服务器的443端口。</p><p>服务器必须要有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。</p><p>服务器将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。</p><p>客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。</p><p>客户端将公钥加密后的密钥发送到服务器。</p><p>服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。</p><p>服务器将加密后的密文返回到客户端。</p><p>客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。</p><hr><h2 id="TCP与UDP的区别："><a href="#TCP与UDP的区别：" class="headerlink" title="TCP与UDP的区别："></a><strong>TCP与UDP的区别：</strong></h2><p>TCP：传输控制协议，TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端需要建立起逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输<br>TCP协议的特点: 面向连接、传输数据安全、传输速度低</p><p>UDP被称之为 【数据报（文）协议】，<strong>UDP协议是一个面向无连接的协议，传输数据时候，不需要建立连接</strong>，不管对方服务器是否启动，【直接将数据，数据源和目的地都封装到数据包，直接发送】，每个数据包的大小被限制在64KB，因为连接不可靠而且是面向无连接，所以它<strong>传输速度快</strong>，但是容易<strong>丢包【数据】</strong>，日日常应用中：视频、游戏等等</p><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p><ul><li>TCP面向连接，UDP面向非连接即发送数据前不需要建立链接</li><li>TCP提供可靠的服务（数据传输），UDP无法保证</li><li>TCP面向字节流，UDP面向报文</li><li>TCP数据传输慢，UDP数据传输快</li></ul><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别"></p><hr><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a><strong>状态码</strong></h2><table><thead><tr><th>100</th><th>Continue</th><th>继续。客户端应继续其请求</th></tr></thead><tbody><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr></tbody></table><ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li></ul><hr><h2 id="Http的长连接和短连接-x2F-x2F-x2F-TCP长连接短连接"><a href="#Http的长连接和短连接-x2F-x2F-x2F-TCP长连接短连接" class="headerlink" title="Http的长连接和短连接&#x2F;&#x2F;&#x2F;TCP长连接短连接"></a><strong>Http的长连接和短连接</strong>&#x2F;&#x2F;&#x2F;TCP长连接短连接</h2><p>实际上没有http长连接短连接这一说，HTTP协议是基于请求&#x2F;响应模式的.因此只要服务端给了响应，本次HTTP连接就结束了，或者更准确的说，是本次HTTP请求就结束了。http长链接短连接的本质上就是tcp的长链接短连接，TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说。HTTP协议说到底是应用层的协议，而TCP才是真正的传输层协议，只有负责传输的这一层才需要建立连接。</p><p><strong>长连接</strong>可以<strong>省去较多的TCP建立和关闭的操作，减少浪费，节约时间</strong>。对于频繁请求资源的客户来说，较适用长连接。</p><p><strong>短连接</strong>对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户<strong>请求频繁</strong>，将在<strong>TCP的建立和关闭操作上浪费时间和带宽</strong>。</p><p><strong>TCP连接：</strong></p><p>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的</p><p><strong>tcp短连接：</strong></p><p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client&#x2F;server间传递一次读写操作</p><p><strong>TCP长链接：</strong></p><p>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p><p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p><p><strong>长连接短连接操作过程</strong></p><p>短连接的操作步骤是：<br>建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接<br>长连接的操作步骤是：<br>建立连接——数据传输…（保持连接）…数据传输——关闭连接</p><hr><h2 id="HTTP-1-0和HTTP-1-1的主要区别是什么"><a href="#HTTP-1-0和HTTP-1-1的主要区别是什么" class="headerlink" title="HTTP 1.0和HTTP 1.1的主要区别是什么?"></a>HTTP 1.0和HTTP 1.1的主要区别是什么?</h2><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ol><li><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误状态响应码</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>长连接</strong>，1.0默认是短连接；1.1默认是长连接。</li></ol><hr><h2 id="URI和URL的区别是什么"><a href="#URI和URL的区别是什么" class="headerlink" title="URI和URL的区别是什么?"></a>URI和URL的区别是什么?</h2><p>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</p><p>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源</p><hr><p>什么是程序局限性？为什么会有程序的空间局限性</p><p>网络协议的三个核心要素？作用？</p><p>为了实现重定位，需要哪些硬件？</p><p>在交互系统中，非剥夺是不是一个好的策略，为什么？</p><p>何为死锁？何为系统调用？</p><p>CPU不执行在干什么？</p><p>同步和互斥</p><p>中断和陷入的区别</p><p>DBMS支持哪几种数据模型</p><p>DNS域名系统的工作原理</p><p>防火墙的端口防护指 什么？</p><p>对称加密和非对称加密</p><p>从输入网址到获得页面的过程</p><p><strong>TCP协议如何保证可靠传输</strong></p><p><strong>在浏览器中输入url地址 -&gt;&gt; 显示主页的过程</strong></p><p><img src="https://img-blog.csdnimg.cn/20200829160841347.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5MTcyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>总体来说分为以下几个过程:</p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>释放TCP连接</li><li>浏览器解析渲染页面</li></ol><p><strong>各种协议与HTTP协议之间的关系</strong></p><h2 id="get-post-区别"><a href="#get-post-区别" class="headerlink" title="get post 区别"></a>get post 区别</h2><ul><li>从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；</li><li>从请求参数形式上看，GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name&#x3D;test1&amp;id&#x3D;123456. POST方法是把提交的数据放在HTTP包的Body中.</li><li>从请求的大小看，GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</li><li>就安全性而言，GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</li></ul><p><img src="https://pics3.baidu.com/feed/574e9258d109b3de0cf26843b8628589810a4cb6.png?token=ca1e944352ab3f647cb799cd4570ebb9" alt="img"></p><h2 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a><strong>session和cookie</strong></h2><p>Cookie是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个Cookie，客户端就把Cookie保存起来。在客户端下次向同一服务器再发起请求时，Cookie被携带发送到服务器。服务器就是根据这个Cookie来确认身份的。</p><p>session指的就是服务器和客户端一次会话的过程。Session利用Cookie进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个Session结束时，其实就是意味着这个Cookie就过期了。Session对象存储着特定用户会话所需的属性及配置信息。</p><p><img src="https://pics2.baidu.com/feed/77094b36acaf2eddb4f07d3cfbcde8e13b0193c3.png?token=0dccae3c1cca868f4d2a80e713fc1e54" alt="img"></p><h2 id="简单说一下你了解的端口及对应的服务"><a href="#简单说一下你了解的端口及对应的服务" class="headerlink" title="简单说一下你了解的端口及对应的服务"></a>简单说一下你了解的端口及对应的服务</h2><ul><li>21 文件传输协议</li><li>53 DNS域名服务器</li><li>80 HTTP超文本传输协议</li><li>443 HTTPS</li><li>1521 Oracle数据库默认端口</li><li>3306 mysql数据库默认端口</li></ul><h2 id="IP地址有哪些分类？"><a href="#IP地址有哪些分类？" class="headerlink" title="IP地址有哪些分类？"></a><strong>IP地址有哪些分类？</strong></h2><p>一般可以这么认为，IP地址&#x3D;网络号+主机号。</p><p>网络号：它标志主机所连接的网络地址表示属于互联网的哪一个网络。主机号：它标志主机地址表示其属于该网络中的哪一台主机。IP地址分为A，B，C，D，E五大类：</p><p>A类地址(1<del>126)：以0开头，网络号占前8位，主机号占后面24位。B类地址(128</del>191)：以10开头，网络号占前16位，主机号占后面16位。C类地址(192<del>223)：以110开头，网络号占前24位，主机号占后面8位。D类地址(224</del>239)：以1110开头，保留位多播地址。E类地址(240~255)：以11110开头，保留位为将来使用</p><p>在浏览器输入网址之后执行会发生什么？</p><ul><li>查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器</li><li>浏览器向IP对应的web服务器发送一个HTTP请求</li><li>服务器响应请求，发回网页内容</li><li>浏览器解析网页内容</li></ul><p>简单解释一下ARP协议的工作过程</p><h2 id="HTTP协议包括哪些请求方式？"><a href="#HTTP协议包括哪些请求方式？" class="headerlink" title="HTTP协议包括哪些请求方式？"></a>HTTP协议包括哪些请求方式？</h2><ul><li>GET：对服务器资源的简单请求</li><li>POST：用于发送包含用户提交数据的请求</li></ul><p>————以及————</p><ul><li>HEAD：类似于GET请求，不过返回的响应中没有具体内容，用于获取报头</li><li>PUT：传说中请求文档的一个版本</li><li>DELETE：发出一个删除指定文档的请求</li><li>TRACE：发送一个请求副本，以跟踪其处理进程</li><li>OPTIONS：返回所有可用的方法，检查服务器支持哪些方法</li><li>CONNECT：用于ssl隧道的基于代理的请求</li></ul><h2 id="在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？"><a href="#在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？" class="headerlink" title="在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？"></a><strong>在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？</strong></h2><p>在HTTP中响应体的<strong>Connection</strong>字段指定为keep-alive即可</p><h2 id="TCP-和-UDP-分别对应的常见应用层协议有哪些？"><a href="#TCP-和-UDP-分别对应的常见应用层协议有哪些？" class="headerlink" title="TCP 和 UDP 分别对应的常见应用层协议有哪些？"></a><strong>TCP 和 UDP 分别对应的常见应用层协议有哪些？</strong></h2><p><strong>基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH</strong></p><p><strong>HTTP</strong>：HyperText Transfer Protocol（超文本传输协议），默认端口80<strong>FTP</strong>: File Transfer Protocol (文件传输协议), 默认端口(20用于传输数据，21用于传输控制信息)<strong>SMTP</strong>: Simple Mail Transfer Protocol (简单邮件传输协议) ,默认端口25<strong>TELNET</strong>: Teletype over the Network (网络电传), 默认端口23<strong>SSH</strong>：Secure Shell（安全外壳协议），默认端口 22<strong>基于</strong></p><p><strong>UDP的应用层协议：DNS、TFTP、SNMP</strong></p><p><strong>DNS</strong> : Domain Name Service (域名服务),默认端口 53<strong>TFTP</strong>: Trivial File Transfer Protocol (简单文件传输协议)，默认端口69<strong>SNMP</strong>：Simple Network Management Protocol（简单网络管理协议），通过UDP端口161接收，只有Trap信息采用UDP端口162。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux</title>
    <link href="/2022/06/29/linux/"/>
    <url>/2022/06/29/linux/</url>
    
    <content type="html"><![CDATA[<p><strong>-ls：不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。</strong></p><p><strong>-cd：cd [目录名]  进入目录</strong></p><p>-pwd ：用于查看当前工作目录路径。</p><p><strong>-mkdir ：mkdir 命令用于创建文件夹。</strong></p><p><strong>-rm：删除一个目录中的一个或多个文件或目录</strong>，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。</p><p>-rmdir：从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。</p><p><strong>-mv：移动文件或修改文件名</strong></p><p>-cp：将源文件复制至目标文件，或将多个源文件复制至目标目录。</p><p>-cat：cat 命令用于连接文件并打印到标准输出设备上。</p><p>-more：功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读</p><p>-less：less 与 more 类似，但使用 less 可以随意浏览文件</p><p>-tail：用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p><p>-head：head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。</p><p>-which：查看可执行文件的位置。</p><p>-whereis：查看文件的位置。</p><p>-locate：配合数据库查看文件位置。</p><p>-find：实际搜寻硬盘查询文件名称</p><p>-chmod：用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限</p><p>-tar：用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能</p><p>-chown:将指定文件的拥有者改为指定的用户或组</p><p>-df：显示磁盘空间使用情况</p><p>-du：命令也是查看使用空间的</p><p>-ln：功能是为文件在另外一个位置建立一个同步的链接</p><p>-date：显示或设定系统的日期与时间。</p><p>-grep：强大的文本搜索命令</p><p>-wc：wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出</p><p>-ps：用来查看当前运行的进程状态</p><p>-top：显示当前系统正在执行的进程的相关信息</p><p>-kill：发送指定的信号到相应进程</p><p>-free：显示系统内存使用情况</p><p>mkdir 目录名称 ： 增加目录<br>ls或者ll （ll是ls -l的缩写，ll命令以看到该目录下的所有目录和文件的详细信息）：查看目录信息<br>find 目录 参数 ： 寻找目录（查）<br><strong>mv 目录名称 新目录名称 ： 修改目录的名称（改）</strong><br>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用<br>来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。<br><strong>mv 目录名称 目录的新位置 ： 移动目录的位置—剪切（改）</strong><br>注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不<br>同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。<br>cp -r 目录名称 目录拷贝的目标位置 ： 拷贝目录（改），-r代表递归拷贝<br>注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归<br><strong>rm [-rf] 目录 : 删除目录（删）</strong><br>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文<br>件，都直接使用 rm -rf 目录&#x2F;文件&#x2F;压缩包<br>文件的操作命令（增删改查）<br>touch 文件名称 : 文件的创建（增）<br>cat&#x2F;more&#x2F;less&#x2F;tail 文件名称 文件的查看（查）<br>cat ： 只能显示最后一屏内容<br>more ： 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看<br>less ： 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看<br>tail-10 ： 查看文件的后10行，Ctrl+C结束<br>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变<br>化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化<br><strong>vim 文件 ： 修改文件的内容（改）</strong><br>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐<br>述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。<br>在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：<br>vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件 ——-&gt;按Esc进入底行模式—–&gt;输 入:wq&#x2F;q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）<br>rm -rf 文件 ： 删除文件（删）<br>同目录删除：熟记 rm -rf 文件 即可<br>压缩文件的操作命令<br>1）打包并压缩文件：<br>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令： tar -zcvf 打包压缩后的 文件名 要打包压缩的文件 其中：<br>z：调用gzip压缩命令进行压缩<br>c：打包文件<br>v：显示运行过程<br>f：指定文件名<br>比如：加入test目录下有三个文件分别是 :aaa.txt bbb.txt ccc.txt,如果我们要打包test目录并指定压缩后的压缩包名<br>称为test.tar.gz可以使用命令： tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt 或： tar -zcvf test.tar.gz &#x2F;test&#x2F; 2）解压压缩包：<br>命令：tar [-xvf] 压缩文件<br>其中：x：代表解压<br>示例：<br>1 将&#x2F;test下的test.tar.gz解压到当前目录下可以使用命令： tar -xvf test.tar.gz<br>2 将&#x2F;test下的test.tar.gz解压到根目录&#x2F;usr下: tar -xvf xxx.tar.gz -C &#x2F;usr （- C代表指定解压的位置）<br>其他常用命令<br>pwd ： 显示当前所在位置<br>grep 要搜索的字符串 要搜索的文件 –color ： 搜索命令，–color代表高亮显示<br>ps -ef &#x2F; ps aux ： 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看<br>特定的进程可以使用这样的格式： ps aux|grep redis （查看包括redis字符串的进程）<br>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的<br>状态。<br>kill -9 进程的pid ： 杀死进程（-9 表示强制终止。）<br>先用ps查找进程，然后用kill杀掉<br>网络通信命令：<br>查看当前系统的网卡信息：ifconfig<br>查看与某台机器的连接情况：ping<br>查看当前系统的端口使用：netstat -an<br>shutdown ： shutdown -h now ： 指定现在立即关机； shutdown +5 “System will shutdown after 5 minutes” :指定5分钟后关机，同时送出警告信息给登入用户。<br>reboot ： reboot ： 重开机。 reboot -w ： 做个重开机的模拟（只有纪录并不会真的重开机）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2022/06/29/sjjg/"/>
    <url>/2022/06/29/sjjg/</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>算法描述</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p><img src="https://img-blog.csdnimg.cn/20190712143006969.gif" alt="冒泡排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">44</span>, <span class="hljs-number">38</span>, <span class="hljs-number">5</span>, <span class="hljs-number">47</span>, <span class="hljs-number">15</span>, <span class="hljs-number">36</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">2</span>, <span class="hljs-number">46</span>, <span class="hljs-number">4</span>, <span class="hljs-number">19</span>, <span class="hljs-number">50</span>, <span class="hljs-number">48</span>&#125;;<br><span class="hljs-comment">// 只需要修改成对应的方法名就可以了</span><br>    bubbleSort(array);<br><br>    System.out.println(Arrays.toString(array));<br>&#125;<br><br><br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description:冒泡排序</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> array 需要排序的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> JourWon</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019/7/11 9:54</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br><span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.length &lt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> array.length;<br><br><span class="hljs-comment">// 外层循环控制比较轮数i</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br><span class="hljs-comment">// 内层循环控制每一轮比较次数，每进行一轮排序都会找出一个较大值</span><br><span class="hljs-comment">// (array.length - 1)防止索引越界，(array.length - 1 - i)减少比较次数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; length - <span class="hljs-number">1</span> - i; j++) &#123;<br><span class="hljs-comment">// 前面的数大于后面的数就进行交换</span><br><span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[j + <span class="hljs-number">1</span>];<br>array[j + <span class="hljs-number">1</span>] = array[j];<br>array[j] = temp;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>算法描述</p><p>第一次从待排序的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313">数据元素</a>中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F/1066239">排序</a>是不稳定的排序方法。</p><p>不稳定为什么？</p><p>如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。</p><p><img src="https://img-blog.csdnimg.cn/20190712143023558.gif" alt="选择排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">44</span>, <span class="hljs-number">38</span>, <span class="hljs-number">5</span>, <span class="hljs-number">47</span>, <span class="hljs-number">15</span>, <span class="hljs-number">36</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">2</span>, <span class="hljs-number">46</span>, <span class="hljs-number">4</span>, <span class="hljs-number">19</span>, <span class="hljs-number">50</span>, <span class="hljs-number">48</span>&#125;;<br><span class="hljs-comment">// 只需要修改成对应的方法名就可以了</span><br>    selectionSort(array);<br><br>    System.out.println(Arrays.toString(array));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 选择排序</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> JourWon</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019/7/11 23:31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br><span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.length &lt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> array.length;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-comment">// 保存最小数的索引</span><br><span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; length; j++) &#123;<br><span class="hljs-comment">// 找到最小的数</span><br><span class="hljs-keyword">if</span> (array[j] &lt; array[minIndex]) &#123;<br>minIndex = j;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 交换元素位置</span><br><span class="hljs-keyword">if</span> (i != minIndex) &#123;<br>swap(array, minIndex, i);<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 交换元素位置</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> b</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> JourWon</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019/7/11 17:57</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[a];<br>array[a] = array[b];<br>array[b] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>算法描述</p><p>首先设定一个分界值，通过该分界值将数组分成左右两部分</p><p>(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。</p><p>(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理<img src="https://img-blog.csdnimg.cn/20190712143139347.gif" alt="快速排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 快速排序</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> array</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> JourWon</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019/7/11 23:39</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>quickSort(array, <span class="hljs-number">0</span>, array.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br><span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || left &gt;= right || array.length &lt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> partition(array, left, right);<br>quickSort(array, left, mid);<br>quickSort(array, mid + <span class="hljs-number">1</span>, right);<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[left];<br><span class="hljs-keyword">while</span> (right &gt; left) &#123;<br><span class="hljs-comment">// 先判断基准数和后面的数依次比较</span><br><span class="hljs-keyword">while</span> (temp &lt;= array[right] &amp;&amp; left &lt; right) &#123;<br>--right;<br>&#125;<br><span class="hljs-comment">// 当基准数大于了 arr[left]，则填坑</span><br><span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>array[left] = array[right];<br>++left;<br>&#125;<br><span class="hljs-comment">// 现在是 arr[right] 需要填坑了</span><br><span class="hljs-keyword">while</span> (temp &gt;= array[left] &amp;&amp; left &lt; right) &#123;<br>++left;<br>&#125;<br><span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>array[right] = array[left];<br>--right;<br>&#125;<br>&#125;<br>array[left] = temp;<br><span class="hljs-keyword">return</span> left;<br>&#125;<br><br><br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">44</span>, <span class="hljs-number">38</span>, <span class="hljs-number">5</span>, <span class="hljs-number">47</span>, <span class="hljs-number">15</span>, <span class="hljs-number">36</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">2</span>, <span class="hljs-number">46</span>, <span class="hljs-number">4</span>, <span class="hljs-number">19</span>, <span class="hljs-number">50</span>, <span class="hljs-number">48</span>&#125;;<br><span class="hljs-comment">// 只需要修改成对应的方法名就可以了</span><br>    quickSort(array);<br><br>    System.out.println(Arrays.toString(array));<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><strong>第一轮：</strong>从第二位置的 2 开始比较，比前面 5 小，交换位置。</p><p><strong>第二轮：</strong>第三位置的 4 比前一位置的 5小，交换位置，依次往前比较。</p><p><strong>第三轮：</strong>第四位置的 6 比前一位置的 5大，无需交换位置。</p><p><strong>第四轮：</strong>第五位置的 1 比前一位置的 6 小，交换位置，再依次往前比较。</p><p><strong>第五轮：</strong>第六位置的 3 比前一位置的 6 小，交换位置，再依次往前比较。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1397904/1618984664195-adfafd58-f373-4250-8a20-a82bed49e036.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_15,text_TmV1dGVjaA==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>在数组[130,150,170,190,210,230,250,270,290,310]中查找数字190，红色为二分线(折半线)，灰色为查找区域，黑色为排除区域。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy81LzI1L2E5ZWE3ZTVkNzQwM2I1NDEwYzJlZmQwOTQ0Njc1MWZk?x-oss-process=image/format,png" alt="img"></p><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法，前提是<strong>数据结构必须先排好序</strong>，时间复杂度可以表示O(h)&#x3D;O(log2n)，以2为底，n的对数。其缺点是要求待查表为有序表，且插入删除困难。</p><p><strong>左加右不加，找右缩左，找左缩右</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearch</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">12</span>, <span class="hljs-number">23</span>, <span class="hljs-number">43</span>, <span class="hljs-number">66</span>, <span class="hljs-number">98</span>, <span class="hljs-number">100</span>&#125;;<br>        System.out.println(binarySort(arr, <span class="hljs-number">23</span>));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 循环实现二分查找</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-comment">//第一个下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//最后一个下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//防越界</span><br>        <span class="hljs-keyword">if</span> (key &lt; arr[low] || key &gt; arr[high] || low &gt; high) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>            mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (key &lt; arr[mid]) &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; arr[mid]) &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>二分查找中中间值的计算</p><p>这是一个经典的话题，如何计算二分查找中的中值？大家一般给出了两种计算方法：</p><p>算法一： mid &#x3D; (low + high) &#x2F; 2<br>算法二： <strong>mid &#x3D; low + (high – low)&#x2F;2</strong><br>乍看起来，算法一简洁，算法二提取之后，跟算法一没有什么区别。但是实际上，区别是存在的。算法一的做法，在极端情况下，(low + high)存在着溢出的风险，进而得到错误的mid结果，导致程序错误。而算法二能够保证计算出来的mid，一定大于low，小于high，不存在溢出的问题。</p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序可用于最大最小值相差较大的数据情况，比如[9012,19702,39867,68957,83556,102456]。<br>但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。</p><p>思想：</p><p>桶排序的基本思想是：<code>把数组 arr 划分为n个大小相同子区间（桶），每个子区间各自排序，最后合并</code>。<br>计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。</p><p>1.找出待排序数组中的最大值max、最小值min<br>2.我们使用 动态数组ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max-min)&#x2F;arr.length+1<br>3.遍历数组 arr，计算每个元素 arr[i] 放的桶<br>4.每个桶各自排序<br>5.遍历桶数组，把排序好的元素放进输出数组</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li><p>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</p></li><li><p>对这两个子序列分别采用归并排序；</p></li><li><p>将两个排序好的子序列合并成一个最终的排序序列。</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1397904/1618994698092-5687147f-8971-4982-b2bb-1283b243ec8d.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_19,text_TmV1dGVjaA==,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><strong>什么叫递归</strong></p><p>递归函数就是直接或间接调用自身的函数，也就是自身调用自己</p><p>一般什么时候使用递归？</p><p>需满足的两个条件</p><p>有反复执行的过程(调用自身)<br>有跳出反复执行过程的条件(递归出口)<br>经典问题：阶乘</p><p>数据结构的存储结构分为三类</p><ul><li>线性表：顺序表(就是常用的数组)、链表、栈和队列   （适合一对一）<ul><li>顺序表：连续存储</li><li>链表：离散存储</li><li>栈：栈中的元素只能从线性表的一端进出（另一端封死），且要遵循“<strong>先入后出</strong>”的原则，即先进栈的元素后出栈。</li><li>队列：队列中的元素只能从线性表的一端进，从另一端出，且要遵循“<strong>先入先出</strong>”的特点，即先进队列的元素也要先出队列。</li></ul></li><li>树结构：普通树、二叉树、线索二叉树   （适合一对多）<ul><li>普通树</li></ul></li><li>图存储结构   （适合多对多）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>springboot</title>
    <link href="/2022/06/29/springboot/"/>
    <url>/2022/06/29/springboot/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是springboot-？"><a href="#1-什么是springboot-？" class="headerlink" title="1 什么是springboot ？"></a><strong>1</strong> <strong>什么是springboot ？</strong></h3><p>用来简化spring应用的初始搭建以及开发过程 使用特定的方式来进行配置（properties或yml文件）</p><p>创建独立的spring引用程序 main方法运行 </p><p>嵌入的Tomcat 无需部署war文件 </p><p>简化maven配置 </p><p>自动配置spring添加对应功能starter自动化配置 </p><p>答：spring boot来简化spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用</p><h3 id="2-Springboot-有哪些优点？"><a href="#2-Springboot-有哪些优点？" class="headerlink" title="2 Springboot 有哪些优点？"></a><strong>2</strong> <strong>Springboot 有哪些优点？</strong></h3><p>-快速创建独立运行的spring项目与主流框架集成 </p><p>-使用嵌入式的servlet容器，应用无需打包成war包</p><p>-starters自动依赖与版本控制 </p><p>-大量的自动配置，简化开发，也可修改默认值 </p><p>-准生产环境的运行应用监控 </p><p>-与云计算的天然集成</p><p>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？<br>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。</p><p>@ComponentScan：Spring组件扫描。</p><h3 id="什么是-YAML？"><a href="#什么是-YAML？" class="headerlink" title="什么是 YAML？"></a>什么是 YAML？</h3><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p><h3 id="YAML-配置的优势在哪里"><a href="#YAML-配置的优势在哪里" class="headerlink" title="YAML 配置的优势在哪里 ?"></a>YAML 配置的优势在哪里 ?</h3><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p><p>配置有序，在一些特殊的场景下，配置有序很关键<br>支持数组，数组中的元素可以是基本数据类型也可以是对象<br>简洁</p><h3 id="如何在自定义端口上运行-Spring-Boot-应用程序？"><a href="#如何在自定义端口上运行-Spring-Boot-应用程序？" class="headerlink" title="如何在自定义端口上运行 Spring Boot 应用程序？"></a>如何在自定义端口上运行 Spring Boot 应用程序？</h3><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在application.properties 中指定端口。server.port &#x3D; 8090</p><h3 id="Spring-Boot-是否可以使用-XML-配置"><a href="#Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="Spring Boot 是否可以使用 XML 配置 ?"></a>Spring Boot 是否可以使用 XML 配置 ?</h3><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p><h3 id="4-Spring-Boot、-Spring-MVC-和-Spring-有什么区别？"><a href="#4-Spring-Boot、-Spring-MVC-和-Spring-有什么区别？" class="headerlink" title="4 Spring Boot、****Spring MVC 和 Spring 有什么区别？"></a><strong>4 Spring Boot、****Spring MVC 和 Spring 有什么区别？</strong></h3><p>1、Spring</p><p>Spring最重要的特征是依赖注入。所有 SpringModules 不是依赖注入就是 IOC 控制反转。</p><p>当我们恰当的使用 DI 或者是 IOC 的时候，我们可以开发松耦合应用。松耦合应用的单元测试可以很容易的进行。</p><p>2、Spring MVC</p><p>Spring MVC 提供了一种分离式的方法来开发 Web 应用。通过运用像 DispatcherServelet，MoudlAndView 和 ViewResolver 等一些简单的概念，开发 Web 应用将会变的非常简单。</p><p>3、SpringBoot</p><p>Spring 和 SpringMVC 的问题在于需要配置大量的参数。</p><p>Spring Boot 通过一个自动配置和启动的项来目解决这个问题。为了更快的构建产品就绪应用程序，Spring Boot 提供了一些非功能性特征。</p><h3 id="4-springboot底层原理？"><a href="#4-springboot底层原理？" class="headerlink" title="4.springboot底层原理？"></a><strong>4.springboot底层原理？</strong></h3><ol><li>什么是springboot<br>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。</li></ol><p>spring大家都知道，boot是启动的意思。所以，spring boot其实就是一个启动spring项目的一个工具而已。从最根本上来讲，Spring Boot就是一些库的集合，它能够被任意项目的构建系统所使用。</p><ol start="2"><li>为什么会出现<br>以前在写spring项目的时候，要配置各种xml文件，还记得曾经被ssh框架支配的恐惧。随着spring3，spring4的相继推出，约定大于配置逐渐成为了开发者的共识，大家也渐渐的从写xml转为写各种注解，在spring4的项目里，你甚至可以一行xml都不写。</li></ol><p>虽然spring4已经可以做到无xml，但写一个大项目需要茫茫多的包，maven配置要写几百行，也是一件很可怕的事。</p><p>现在，快速开发一个网站的平台层出不穷，nodejs，php等虎视眈眈，并且脚本语言渐渐流行了起来（Node JS，Ruby，Groovy，Scala等），spring的开发模式越来越显得笨重。</p><p>在这种环境下，spring boot伴随着spring4一起出现了。</p><ol start="3"><li>可以做什么<br>那么，spring boot可以做什么呢？</li></ol><p>spring boot并不是一个全新的框架，它不是spring解决方案的一个替代品，而是spring的一个封装。所以，你以前可以用spring做的事情，现在用spring boot都可以做。</p><p>现在流行微服务与分布式系统，springboot就是一个非常好的微服务开发框架，你可以使用它快速的搭建起一个系统。同时，你也可以使用spring cloud（Spring Cloud是一个基于Spring Boot实现的云应用开发工具）来搭建一个分布式的网站。</p><ol start="4"><li>优点<br>4.1 使编码变得简单<br>spring boot采用java config的方式，对spring进行配置，并且提供了大量的注解，极大地提高了工作效率。</li></ol><p>4.2 使配置变得简单</p><p>spring boot提供许多默认配置，当然也提供自定义配置。但是所有spring boot的项目都只有一个配置文件：application.properties&#x2F;application.yml。用了spring boot，再也不用担心配置出错找不到问题所在了。</p><p>4.3 使部署变得简单<br>spring boot内置了三种servlet容器：tomcat，jetty，undertow。</p><p>所以，你只需要一个java的运行环境就可以跑spring boot的项目了。spring boot的项目可以打成一个jar包，然后通过java -jar xxx.jar来运行。（spring boot项目的入口是一个main方法，运行该方法即可。 ）</p><p>4.4 使监控变得简单<br>spring boot提供了actuator包，可以使用它来对你的应用进行监控。它主要提供了以下功能：</p><p>我们将在后续文章中学习它。</p><ol start="5"><li>相关技术<br>5.1 微服务架构<br>微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。</li></ol><p>比如我要开发一个购票系统。就可以简单的拆分为用户管理微服务和售票系统微服务。两个服务都可以独立运行，都有自己的数据库，他们之间通过restapi 进行通信。</p><p>而spring boot就是搭建微服务的一个很好的选择。</p><p>5.2 restful<br>restful 是一种api的风格，后面的文章里，会着重讲解。spring boot可以很方便的提供restful 风格的api。</p><p>5.3 spring cloud<br>微服务有很多优点，当然也有一些挑战。可以参考这篇文章：<br>微服务实战（一）：微服务架构的优势与不足。</p><p>微服务一般都是运行在分布式环境中的，这可不是简单的写一个ssm框架的小程序就可以解决的，其中需要用到很多技术，比如负载均衡，反向代理，服务治理，配置管理，消息总线等，spring cloud提供了这些技术。并且，spring cloud全家桶是基于spring boot的。</p><p>之后会专门开一个spring cloud的专题。</p><ol start="6"><li>总结<br>来总结一下spring boot的特点。</li></ol><p>独立运行的Spring项目<br>Spring Boot可以以jar包的形式进行独立的运行，使用：java -jar xx.jar 就可以成功的运行项目，或者在应用项目的主程序中运行main函数即可；</p><p>内嵌的Servlet容器<br>我们上面已经讲过。</p><p>提供starter简化Manen配置<br>spring boot提供各种starter，其实就是一些spring bao的集合，只不过spring boot帮我们整合起来了而已。</p><p>上图只是其中的一部分，还有很多其他的。通过这些starter也可以看得出来，spring boot可以和其他主流的框架无缝集成，比如mybatis等。所以，你不需要担心你想用的技术spring boot不支持。</p><p>自动配置Spring，无xml文件<br>Spring Boot会根据我们项目中类路径的jar包&#x2F;类，为jar包的类进行自动配置Bean，这样一来就大大的简化了我们的配置。当然，这只是Spring考虑到的大多数的使用场景，在一些特殊情况，我们还需要自定义自动配置（就在那唯一的配置文件里，而且它不是xml文件！）。</p><p>应用监控<br>Spring Boot提供了基于http、ssh、telnet对运行时的项目进行监控。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>springmvc</title>
    <link href="/2022/06/29/springmvc/"/>
    <url>/2022/06/29/springmvc/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是Spring-MVC-？简单介绍下你对springMVC的理解"><a href="#1、什么是Spring-MVC-？简单介绍下你对springMVC的理解" class="headerlink" title="1、什么是Spring MVC ？简单介绍下你对springMVC的理解?"></a>1、什么是Spring MVC ？简单介绍下你对springMVC的理解?</h3><p>SpringMVC 是spring框架的一部分，是基于java实现MVC的轻量级Web框架，通过把<strong>Model，View，Controller</strong>分离，将web层进行解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><h2 id="SpringMVC作用"><a href="#SpringMVC作用" class="headerlink" title="SpringMVC作用"></a>SpringMVC作用</h2><p>首先他轻量，高效，独立开发，可以扩展，可以维护，可以复用，可以测试，它即实现了业务逻辑，与数据分离展示，且各模块最大限度的解耦独立开发。</p><h3 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h3><p>（1）可以支持各种视图技术,而不仅仅局限于JSP；</p><p>（2）与Spring框架集成（如IoC容器、AOP等）；</p><p>（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。</p><p>（4） 支持各种请求资源的映射策略。</p><h3 id="MVC是什么？MVC设计模式的好处有哪些"><a href="#MVC是什么？MVC设计模式的好处有哪些" class="headerlink" title="MVC是什么？MVC设计模式的好处有哪些"></a>MVC是什么？MVC设计模式的好处有哪些</h3><p>mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。模型（model）-视图（view）-控制器（controller），三层架构的设计模式。用于实现前端页面的展现与后端业务数据处理的分离。</p><p>mvc设计模式的好处</p><p>1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。</p><p>2.有利于系统的并行开发，提升开发效率。</p><h3 id="Spring-MVC常用的注解有哪些？"><a href="#Spring-MVC常用的注解有哪些？" class="headerlink" title="Spring MVC常用的注解有哪些？"></a>Spring MVC常用的注解有哪些？</h3><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p><p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p><h3 id="SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？"><a href="#SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？" class="headerlink" title="SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？"></a>SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？</h3><p>答：一般用@Controller注解,也可以使用@RestController,@RestController注解相当于@ResponseBody ＋ @Controller,表示是表现层,除此之外，一般不用别的注解代替。</p><h3 id="Controller注解的作用"><a href="#Controller注解的作用" class="headerlink" title="@Controller注解的作用"></a>@Controller注解的作用</h3><p>在Spring MVC 中，控制器Controller 负责处理由前端控制器DispatcherServlet 分发的请求，它把用户请求的数据经过业务层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。</p><p>@Controller  你无需继承特定的类或实现特定的接口，然后用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p><h3 id="RequestMapping注解的作用"><a href="#RequestMapping注解的作用" class="headerlink" title="@RequestMapping注解的作用"></a>@RequestMapping注解的作用</h3><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>（RequestMapping注解有六个属性</p><p><strong>value， method</strong></p><p>value： 指定请求的实际地址，指定的地址可以是URI Template 模式；</p><p>method： 指定请求的method类型， GET、POST等；）</p><h3 id="ResponseBody注解的作用"><a href="#ResponseBody注解的作用" class="headerlink" title="@ResponseBody注解的作用"></a>@ResponseBody注解的作用</h3><p>作用： 注解实现将conreoller方法返回对象转化为json对象响应给客户。</p><p>（使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；）</p><h3 id="PathVariable和-RequestParam的区别"><a href="#PathVariable和-RequestParam的区别" class="headerlink" title="@PathVariable和@RequestParam的区别"></a>@PathVariable和@RequestParam的区别</h3><p>请求路径上有个id的变量值，可以通过@PathVariable来获取 @RequestMapping(value &#x3D; “&#x2F;page&#x2F;{id}”, method &#x3D; RequestMethod.GET)</p><p>@RequestParam用来获得静态的URL请求入参 spring注解时action里用到。</p><h3 id="介绍一下-WebApplicationContext"><a href="#介绍一下-WebApplicationContext" class="headerlink" title="介绍一下 WebApplicationContext"></a><strong>介绍一下 WebApplicationContext</strong></h3><p>WebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。</p><h3 id="Spring-MVC的异常处理？"><a href="#Spring-MVC的异常处理？" class="headerlink" title="Spring MVC的异常处理？"></a>Spring MVC的异常处理？</h3><p>答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p><h3 id="如果在拦截请求中，我想拦截get方式提交的方法-怎么配置"><a href="#如果在拦截请求中，我想拦截get方式提交的方法-怎么配置" class="headerlink" title="如果在拦截请求中，我想拦截get方式提交的方法,怎么配置"></a>如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</h3><p>答：可以在@RequestMapping注解里面加上method&#x3D;RequestMethod.GET。</p><h3 id="怎样在方法里面得到Request-或者Session？"><a href="#怎样在方法里面得到Request-或者Session？" class="headerlink" title="怎样在方法里面得到Request,或者Session？"></a>怎样在方法里面得到Request,或者Session？</h3><p>答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。</p><h3 id="如果想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#如果想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="如果想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</h3><p>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。</p><h3 id="如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h3><p>答：直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。</p><h3 id="Spring-MVC中函数的返回值是什么？"><a href="#Spring-MVC中函数的返回值是什么？" class="headerlink" title="Spring MVC中函数的返回值是什么？"></a>Spring MVC中函数的返回值是什么？</h3><p>答：返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。</p><h3 id="Spring-MVC用什么对象从后台向前台传递数据的？"><a href="#Spring-MVC用什么对象从后台向前台传递数据的？" class="headerlink" title="Spring MVC用什么对象从后台向前台传递数据的？"></a>Spring MVC用什么对象从后台向前台传递数据的？</h3><p>答：通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p><h3 id="怎么样把ModelMap里面的数据放入Session里面？"><a href="#怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="怎么样把ModelMap里面的数据放入Session里面？"></a>怎么样把ModelMap里面的数据放入Session里面？</h3><p>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p><h3 id="Spring-MVC里面拦截器是怎么写的"><a href="#Spring-MVC里面拦截器是怎么写的" class="headerlink" title="Spring MVC里面拦截器是怎么写的"></a>Spring MVC里面拦截器是怎么写的</h3><p>有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在Spring MVC的配置文件中配置拦截器即可：</p><h3 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h3><p>（1）解决post请求乱码问题：</p><p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p><p>mvc流程</p><ol><li>用户发请求</li><li>Servlet接收请求数据，并调用对应的业务逻辑方法</li><li>业务处理完毕，返回更新后的数据给Servlet</li><li>servlet转向到JSP，由jsp来渲染页面</li><li>响应给前端更新后的页面</li></ol><p>职责</p><ul><li>controller<ul><li>取得表单数据</li><li>调用业务逻辑</li><li>转向指定的页面</li></ul></li><li>Model<ul><li>业务逻辑</li><li>保存数据的状态</li></ul></li><li>view<ul><li>显示页面</li></ul></li></ul><p><strong>springmvc</strong></p><p>依赖:</p><ul><li>junit    spring-webmvc   servlet-api    jsp-api  jstl</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>spring</title>
    <link href="/2022/06/29/spring/"/>
    <url>/2022/06/29/spring/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是spring？优缺点？"><a href="#1-什么是spring？优缺点？" class="headerlink" title="1.什么是spring？优缺点？"></a>1.什么是spring？优缺点？</h3><p>Spring就是一个轻量级的控制反转（IOC），面向切面编程（AOP）的框架</p><h3 id="spring优缺点"><a href="#spring优缺点" class="headerlink" title="spring优缺点"></a>spring优缺点</h3><p>优点</p><ul><li>Spring是一个开源的免费的框架（容器）</li><li>Spring是一个轻量级的，非入侵式的框架</li><li>控制翻转（IOC）、面向切面编程（AOP）</li><li>支持事务的处理，对框架整合的支持</li></ul><p>缺点</p><p>Spring明明一个很轻量级的框架，却给人感觉大而全<br>Spring依赖反射，反射影响性能<br>使用门槛升高，入门Spring需要较长时间</p><h3 id="2-spring中遇到的什么设计模式"><a href="#2-spring中遇到的什么设计模式" class="headerlink" title="2.spring中遇到的什么设计模式"></a>2.spring中遇到的什么设计模式</h3><p>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；<br>单例模式：Bean默认为单例模式。<br>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；<br>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。<br>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p><h3 id="3-什么是ioc，作用是什么"><a href="#3-什么是ioc，作用是什么" class="headerlink" title="3.什么是ioc，作用是什么"></a>3.什么是ioc，作用是什么</h3><p><strong>IoC</strong>即控制反转，就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。通过容器来实现对象组件的装配和管理</p><p><strong>之前程序是主动创建对象，控制权在我们程序员手上</strong></p><p>使用set注入后，程序不再具有主动性，而是变成了被动的接收对象。</p><p><strong>所谓控制反转：就是获得依赖对象的方式翻转了</strong></p><p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。<br><strong>作用</strong></p><p>解耦，由容器去维护具体的对象</p><p>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</p><h3 id="IOC优点"><a href="#IOC优点" class="headerlink" title="IOC优点"></a>IOC优点</h3><ul><li>IOC 或 依赖注入把应用的代码量降到最低。</li><li>它使应用<strong>容易测试</strong>，单元测试不再需要单例和JNDI查找机制。</li><li>最小的代价和最小的侵入性使松散耦合得以实现。</li><li>IOC容器支持加载服务时的饿汉式初始化和懒加载。</li></ul><p><strong>实现机制</strong>：Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p><h3 id="什么是Spring的依赖注入？"><a href="#什么是Spring的依赖注入？" class="headerlink" title="什么是Spring的依赖注入？"></a>什么是Spring的依赖注入？</h3><p>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找</p><p><strong>依赖注入</strong>：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</p><h4 id="依赖注入的基本原则"><a href="#依赖注入的基本原则" class="headerlink" title="依赖注入的基本原则"></a>依赖注入的基本原则</h4><p>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。</p><h4 id="依赖注入有什么优势"><a href="#依赖注入有什么优势" class="headerlink" title="依赖注入有什么优势"></a>依赖注入有什么优势</h4><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p><p>查找定位操作与应用代码完全无关。<br>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。<br>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</p><h3 id="有哪些不同类型的依赖注入实现方式？"><a href="#有哪些不同类型的依赖注入实现方式？" class="headerlink" title="有哪些不同类型的依赖注入实现方式？"></a>有哪些不同类型的依赖注入实现方式？</h3><p>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p><p>Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p><h3 id="构造函数注入setter-注入-区别"><a href="#构造函数注入setter-注入-区别" class="headerlink" title="构造函数注入setter **注入**区别"></a>构造函数注入setter **注入**区别</h3><table><thead><tr><th><strong>构造函数注入</strong></th><th><strong>setter</strong> <strong>注入</strong></th></tr></thead><tbody><tr><td>没有部分注入</td><td>有部分注入</td></tr><tr><td>不会覆盖 setter 属性</td><td>会覆盖 setter 属性</td></tr><tr><td>任意修改都会创建一个新实例</td><td>任意修改不会创建一个新实例</td></tr><tr><td>适用于设置很多属性</td><td>适用于设置少量属性</td></tr></tbody></table><h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h3><p> 面向切面编程，就是在项目原有的功能基础上，通过AOP去添加新的功能，这些功能是建立在原有功能的基础上的，而且原有的功能并不知道你已经添加了新的功能。比如说，我去银行取钱，取钱是一个功能，取完钱后向我的手机发送一条取钱信息，这就是新加的功能。<br>提高了系统的可维护性。可用于日志、事务处理等。</p><h3 id="解释一下Spring-AOP里面的几个名词"><a href="#解释一下Spring-AOP里面的几个名词" class="headerlink" title="解释一下Spring AOP里面的几个名词"></a>解释一下Spring AOP里面的几个名词</h3><p>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p><p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><p>（3）通知（Advice）：在AOP术语中，切面的工作被称为通知。</p><p>（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p><p>（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。</p><p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p><p>（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：</p><p>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。<br>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。<br>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</p><h3 id="如何给Spring-容器提供配置元数据？Spring有几种配置方式"><a href="#如何给Spring-容器提供配置元数据？Spring有几种配置方式" class="headerlink" title="如何给Spring 容器提供配置元数据？Spring有几种配置方式"></a>如何给Spring 容器提供配置元数据？Spring有几种配置方式</h3><p>这里有三种重要的方法给Spring 容器提供配置元数据。</p><p>XML配置文件。<br>基于注解的配置。<br>基于java的配置。</p><h3 id="Spring配置文件包含了哪些信息"><a href="#Spring配置文件包含了哪些信息" class="headerlink" title="Spring配置文件包含了哪些信息"></a>Spring配置文件包含了哪些信息</h3><p>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p><h3 id="Spring基于xml注入bean的几种方式"><a href="#Spring基于xml注入bean的几种方式" class="headerlink" title="Spring基于xml注入bean的几种方式"></a>Spring基于xml注入bean的几种方式</h3><p>Set方法注入；</p><p>构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</p><p>静态工厂注入；</p><p>实例工厂；</p><h3 id="Autowired和-Resource之间的区别"><a href="#Autowired和-Resource之间的区别" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h3><p>@Autowired可用于：构造函数、成员变量、Setter方法</p><h3 id="Autowired和-Resource之间的区别-1"><a href="#Autowired和-Resource之间的区别-1" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h3><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p><p>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>1.@Controller<br>在控制层使用，标识该类是 Spring MVC controller 处理器，用来创建处理 http 请求的对象。</p><p>2.@Service<br>在业务逻辑层使用，用于标注业务层组件。</p><p>3.@Repository   瑞抛死他瑞<br>在数据访问层使用，用于标注数据访问组件，即 DAO 组件。</p><p>4.@Component  肯抛们他<br>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p>5.@Autowired<br>把配置好的 bean 拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。</p><p>6.@Resource<br>它的作用相当于 @Autowired 注解的作用。</p><p>12.@RequestMapping<br>用于映射 Web 请求，包括访问路径和参数。</p><p>13.@ResponseBody<br>支持将返回值放在 response 内，而不是一个页面，通常用户返回 json 数据。</p><p>14.@RestController<br>用于标注控制层组件，包含 @Controller 和 @ResponseBody。</p><p>7.@Bean<br>相当于 XML 中的，放在方法的上面，而不是类，意思是产生一个 Bean，并交给 Spring 的容器管理。</p><p>8.@Configuration<br>声明当前类为配置类，相当于 xml 形式的 Spring 配置。</p><p>9.@ComponentScan<br>用于对 Component 组件进行扫描。</p><p>10.@Value<br>为对应的属性注入值。</p><p>11.@RunWith<br>运行器，Spring 中通常用于对 Junit 的支持。</p><p>15.@RequestParam<br>用于将请求参数区数据映射到功能处理方法的参数上。</p><p>16.@Scope<br>用来配置 Spring Bean 的作用域，它标识 Bean 的作用域。</p><p>17.@Qualifier<br>当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 @Qualifier 注解和 @Autowired 注解通过指定哪一个真正的 bean 将会被装配来消除混乱。</p><p>18.@Transactional<br>通过这个注解可以声明事务，可以添加在类上或者方法上。</p><p>19.@Aspect<br>声明一个切面(类上)使用 @After、@Before、@Around 定义通知(advice)，可直接将拦截规则（切点）作为参数。</p><p>20.@PointCut<br>声明切点，在 java 配置类中使用。</p><p>21.@After<br>在方法执行之后执行(方法上)。</p><p>22.@Before<br>在方法执行之前执行(方法上)。</p><p>23.@Around<br>在方法执行之前与之后执行(方法上)。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mybatis</title>
    <link href="/2022/06/29/mybatis/"/>
    <url>/2022/06/29/mybatis/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是mybatis？"><a href="#1-什么是mybatis？" class="headerlink" title="1.什么是mybatis？"></a>1.什么是mybatis？</h2><ul><li><p>是一款优秀的半 ORM（对象关系映射）的持久层框架</p></li><li><p>几乎避免了大量jdbc代码和手动设置的一些参数和结果集</p></li><li><p>它可以用xml或者注解来配置映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）</p></li></ul><h2 id="2-Mybatis优缺点"><a href="#2-Mybatis优缺点" class="headerlink" title="2.Mybatis优缺点"></a><strong>2.Mybatis优缺点</strong></h2><p>优点：</p><ul><li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；</li><li>提供XML标签，支持编写动态SQL语句，并可重用</li><li>与JDBC相比，减少了大量代码量，消除了JDBC大量冗余的代码，不需要手动开关连接数据库</li><li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）</li><li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护</li><li>能够与Spring很好的集成</li></ul><p>缺点：</p><p>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求</p><p>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><h2 id="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h2><p>1、数据库的连接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。</p><p>​解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">连接池<br><span class="hljs-symbol">dbcp:</span>半自动化操作，不能自动连接<br>c3p0：自动化操作（自动化的加载配置文件，并且可以自动设置到对象中！）<br></code></pre></td></tr></table></figure><p>2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。</p><p>​解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p><p>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p><p>​解决： Mybatis自动将java对象映射至sql语句。</p><p>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p><p>​解决：Mybatis自动将sql执行结果映射至java对象。</p><h2 id="3-mybatis编程步骤"><a href="#3-mybatis编程步骤" class="headerlink" title="3.mybatis编程步骤"></a>3.mybatis编程步骤</h2><p>1、 创建SqlSessionFactory</p><p>2、 通过SqlSessionFactory创建SqlSession</p><p>3、 通过sqlsession执行数据库操作</p><p>4、 调用session.commit()提交事务</p><p>5、 调用session.close()关闭会话</p><h2 id="mybatis工作原理"><a href="#mybatis工作原理" class="headerlink" title="mybatis工作原理"></a>mybatis工作原理</h2><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSVCNyVBNSVFNCVCRCU5QyVFNSU4RSU5RiVFNyU5MCU4Ni5wbmc" alt="MyBatis工作原理" style="zoom:200%;" /><p>1）<strong>读取 MyBatis 配置文件</strong>：mybatis-config.xml ：配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</p><p>2）<strong>加载映射文件</strong>。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p><p>3）<strong>构造会话工厂</strong>：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p><p>4）<strong>创建会话对象</strong>：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</p><p>5）<strong>Executor 执行器</strong>：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p><p>6）<strong>MappedStatement 对象</strong>：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</p><p>7）<strong>输入参数映射</strong>：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。</p><p>8）<strong>输出结果映射</strong>：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</p><h2 id="mybatis功能架构是怎样的？"><a href="#mybatis功能架构是怎样的？" class="headerlink" title="mybatis功能架构是怎样的？"></a>mybatis功能架构是怎样的？</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSU4QSU5RiVFOCU4MyVCRCVFNiU5RSVCNiVFNiU5RSU4NC5wbmc" alt="Mybatis功能框架"></p><p>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</p><p>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</p><p>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</p><h2 id="为什么需要预编译？"><a href="#为什么需要预编译？" class="headerlink" title="为什么需要预编译？"></a>为什么需要预编译？</h2><p>预编译阶段可以优化 SQL 的执行。就是把一个 SQL 预编译后产生的PreparedStatement 对象缓存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。Mybatis默认情况下，将对所有的 SQL 进行预编译。</p><h2 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？-Executor-（一个在ki特）"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？-Executor-（一个在ki特）" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？    Executor （一个在ki特）"></a>Mybatis都有哪些Executor执行器？它们之间的区别是什么？    Executor （一个在ki特）</h2><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p><p>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p><p>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p><p>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p><h2 id="Mybatis中如何指定使用哪一种Executor执行器？"><a href="#Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="Mybatis中如何指定使用哪一种Executor执行器？"></a>Mybatis中如何指定使用哪一种Executor执行器？</h2><p>在Mybatis配置文件中，在<strong>设置（settings）</strong>可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。</p><p>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</p><h2 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false。</p><p>它的原理是，使用cglib创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><h2 id="，-区别"><a href="#，-区别" class="headerlink" title="#{}，${}区别"></a>#{}，${}区别</h2><ul><li>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</li></ul><p>简单说**#{}是经过预编译的,是安全的**。 （加单引号）</p><p>而**${}**是未经过预编译的,<strong>仅仅是取变量的值,是非安全的,存在SQL注入</strong>。（直接）</p><h2 id="在mapper中如何传递多个参数-4种"><a href="#在mapper中如何传递多个参数-4种" class="headerlink" title="在mapper中如何传递多个参数 4种"></a>在mapper中如何传递多个参数 4种</h2><p><strong>方法1：顺序传参法</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">public User selectUser(String name, int deptId);<br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;</span><br>    select * from user<br>    where user_name = #&#123;0&#125; and dept_id = #&#123;1&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>#{}里面的数字代表传入参数的顺序。</p><p>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</p><p><strong>方法2：@Param注解传参法</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">public User selectUser(@Param(&quot;userName&quot;) String name, int @Param(&quot;deptId&quot;) deptId);<br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;</span><br>    select * from user<br>    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>#{}里面的名称对应的是注解@Param括号里面修饰的名称。</p><p>这种方法在参数不多的情况还是比较直观的，推荐使用。</p><p><strong>方法3：Map传参法</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">public User selectUser(Map&lt;String, Object&gt; params);<br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.util.Map&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;</span><br>    select * from user<br>    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>#{}里面的名称对应的是Map里面的key名称。</p><p>这种方法适合传递多个参数，且参数易变能灵活传递的情况。</p><p><strong>方法4：Java Bean传参法</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">public User selectUser(User user);<br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.jourwon.pojo.User&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;</span><br>    select * from user<br>    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>#{}里面的名称对应的是User类里面的成员属性。</p><p>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。</p><h2 id="Mybatis如何执行批量操作"><a href="#Mybatis如何执行批量操作" class="headerlink" title="Mybatis如何执行批量操作"></a>Mybatis如何执行批量操作</h2><p><strong>使用foreach标签</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 批量保存(foreach插入多条数据两种方法)</span><br><span class="hljs-comment">       int addEmpsBatch(@Param(&quot;emps&quot;) List&lt;Employee&gt; emps); --&gt;</span><br><span class="hljs-comment">&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --&gt;</span> //推荐使用<br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addEmpsBatch&quot;</span>&gt;</span><br>    INSERT INTO emp(ename,gender,email,did)<br>    VALUES<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="如何获取生成的主键"><a href="#如何获取生成的主键" class="headerlink" title="如何获取生成的主键"></a>如何获取生成的主键</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;userId&quot;</span> &gt;</span><br>    insert into user( <br>    user_name, user_password, create_time) <br>    values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>parameterType 可以不写，Mybatis可以推断出传入的数据类型。如果想要访问主键，那么应当parameterType 应当是java实体或者Map。这样数据在插入之后 可以通过java实体或者Map 来获取主键值。通过 getUserId获取主键</p><h2 id="如果字段和属性名字不一致怎么办？"><a href="#如果字段和属性名字不一致怎么办？" class="headerlink" title="如果字段和属性名字不一致怎么办？"></a>如果字段和属性名字不一致怎么办？</h2><ul><li>通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</li><li>通过<code>&lt;resultMap&gt;</code>来映射字段名和实体类属性名的一一对应的关系。</li></ul><h2 id="mybatis一级缓存二级缓存"><a href="#mybatis一级缓存二级缓存" class="headerlink" title="mybatis一级缓存二级缓存"></a>mybatis一级缓存二级缓存</h2><p>我们查询的时候需要连接数据库 耗费资源</p><p>一次查询的结果，给他暂存在一个可以直接取到的地方：内存：缓存</p><p>我们再一次查询相同数据的时候，直接走缓存，就不用走数据库了</p><p>mybatis缓存</p><p> <strong>一级缓存</strong></p><p>默认情况下 会开启一级缓存  sqlsession级别的缓存也称为本地缓存</p><p>与数据库同一次会话期间查询到的数据会放在本地缓存中。</p><p>以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库。</p><p>“就是查询两次的话，数据库sql语句走了一次”</p><p>缓存失效的情况：</p><p>1.增删改数据，可能会改变原来的数据，所以必定会刷新缓存</p><p>2.查询不同的东西</p><p>3.查询不同的mapper.xml</p><p>4.手动清理缓存   sqlSession.clearCache();</p><p>一级缓存默认是开启的 ，也关闭不掉</p><p><strong>二级缓存</strong></p><p>二级缓存需要手动开启和配置，他是基于namespace级别的缓存</p><p>一级缓存作用域太低了 ，所以诞生了二级缓存 </p><p>步骤：</p><ul><li>开启全局缓存 在核心配置文件中  <setting name="cacheEnable" value="true"/></li><li>在Mapper.xml中开启二级缓存   <cache/></li><li>也可以自定义参数</li></ul><p>所有的数据都会先放在一级缓存中，只有当会话提交，会话关闭的时候，才会提交到二级缓存中</p><h2 id="mybatis如何实现自动插入、批量插入？"><a href="#mybatis如何实现自动插入、批量插入？" class="headerlink" title="mybatis如何实现自动插入、批量插入？"></a>mybatis如何实现自动插入、批量插入？</h2><p>利用关键字sqlsession、</p><h2 id="MyBatis实现一对一，一对多有几种方式，怎么操作的？"><a href="#MyBatis实现一对一，一对多有几种方式，怎么操作的？" class="headerlink" title="MyBatis实现一对一，一对多有几种方式，怎么操作的？"></a>MyBatis实现一对一，一对多有几种方式，怎么操作的？</h2><p>有联合查询和嵌套查询。</p><p>联合查询是几个表联合查询，只查询一次，通过在resultMap里面的association，collection节点配置一对一，一对多的类就可以完成</p><p>嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，也是通过配置association，collection，但另外一个表的查询通过select节点配置。</p><h2 id="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h2><p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签<strong>trim</strong>|<strong>where</strong>|set|<strong>foreach</strong>|if|choose|when|otherwise|bind。</p><p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p><h2 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><p>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</p><h2 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h2><p>1、Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</p><p>2、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同。</p><p>3、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。</p><p>4、Mapper.xml文件中的namespace即是mapper接口的类路径</p><h2 id="日志作用"><a href="#日志作用" class="headerlink" title="日志作用"></a>日志作用</h2><p>在项目开发中，都不可避免的使用到日志。没有日志虽然不会影响项目的正确运行，但是没有日志的项目可以说是不完整的。日志在调试，错误或者异常定位，数据分析中的作用是不言而喻的。</p><p>调试<br>在Java项目调试时，查看栈信息可以方便地知道当前程序的运行状态，输出的日志便于记录程序在之前的运行结果。如果你大量使用System.out或者System.err，这是一种最方便最有效的方法，但显得不够专业。</p><p>错误定位<br>不要以为项目能正确跑起来就可以高枕无忧，项目在运行一段时候后，可能由于数据问题，网络问题，内存问题等出现异常。这时日志可以帮助开发或者运维人员快速定位错误位置，提出解决方案。</p><p>数据分析<br>大数据的兴起，使得大量的日志分析成为可能，ELK也让日志分析门槛降低了很多。日志中蕴含了大量的用户数据，包括点击行为，兴趣</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>jdbc</title>
    <link href="/2022/06/29/jdbc/"/>
    <url>/2022/06/29/jdbc/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 注入式攻击：</span><br><span class="hljs-comment"> * 用户名： abc  </span><br><span class="hljs-comment"> * 密码：   abc&#x27; or &#x27;1&#x27;=&#x27;1</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * --Statement  PreparedStatement</span><br><span class="hljs-comment"> * 前者存在注入式攻击      后者解决了这个问题</span><br><span class="hljs-comment"> * 前者编译一次，执行一次   后者编译一次，执行N次   后者效率较高一些</span><br><span class="hljs-comment"> * 后者会在编译阶段做类型的安全检查</span><br><span class="hljs-comment"> *综上所述：后者使用比较多 ，极少情况下使用前者，但什么时候使用Statement呢？</span><br><span class="hljs-comment"> *           业务方面必须支持SQL注入的时候</span><br><span class="hljs-comment"> * */</span><br><br><span class="hljs-comment">// 1.注册驱动（告诉java程序，即将要连接的是哪个品牌的数据库）</span><br><span class="hljs-comment">// 2.获取连接（表示jvm的进程和数据库进程之间的通道打开了，这属于进程之间的通信，重量级的，使用完一定要关闭通道）</span><br><span class="hljs-comment">// 3.获取数据库操作对象（专门执行sql语句的对象）</span><br><span class="hljs-comment">// 4.执行sql语句（DQL DML...）</span><br><span class="hljs-comment">// 5.处理查询结果集（只有当第四步执行的是select语句时，才有第五步处理查询结果集）</span><br><span class="hljs-comment">// 6.释放资源（使用完资00源之后一定要关闭资源，java和数据库属于进程间的通信，开启之后一定要关闭）</span><br><span class="hljs-keyword">package</span> com.ggp.jdbc;<br><br><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">jdbcUntil</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 工具类中的构造方法都是私有的。</span><br><span class="hljs-comment">     * 因为工具类当中的方法都是静态的，不需要new对象，直接采用类名调用。</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">jdbcUntil</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//静态代码块在类加载时执行，并且只执行一次</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//获取数据库连接对象，返回连接对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/jdbc?serverTimezone=UTC&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;ggp08250.&quot;</span>);<br>        <span class="hljs-keyword">return</span> connection;<br>    &#125;<br><br>    <span class="hljs-comment">//关闭资源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Connection connection, PreparedStatement preparedStatement, ResultSet resultSet)</span> &#123;<br>        <span class="hljs-keyword">if</span> (resultSet != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                resultSet.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (preparedStatement != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                preparedStatement.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                connection.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ggp.jdbc;<br><br><span class="hljs-keyword">import</span> com.ggp.jdbc.jdbcUntil;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">jdbcTest3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取连接</span><br>            connection = jdbcUntil.getConnection();<br><br><br><br>              <span class="hljs-comment">//增加</span><br><span class="hljs-comment">//            String sql = &quot;insert into dept (deptno,dname,loc) values(?,?,?) &quot;;</span><br><span class="hljs-comment">//            preparedStatement = connection.prepareStatement(sql);</span><br><span class="hljs-comment">//            preparedStatement.setInt(1,130);</span><br><span class="hljs-comment">//            preparedStatement.setString(2,&quot;校部&quot;);</span><br><span class="hljs-comment">//            preparedStatement.setString(3,&quot;河南&quot;);</span><br><span class="hljs-comment">//            int count = preparedStatement.executeUpdate();</span><br><span class="hljs-comment">//            System.out.println(count);</span><br><br><br><br><span class="hljs-comment">//            //删除</span><br><span class="hljs-comment">//            String sql = &quot;delete  from dept where deptno = ? &quot;;</span><br><span class="hljs-comment">//            preparedStatement = connection.prepareStatement(sql);</span><br><span class="hljs-comment">//            preparedStatement.setInt(1,60);</span><br><span class="hljs-comment">//            int count = preparedStatement.executeUpdate();</span><br><span class="hljs-comment">//            System.out.println(count);</span><br><br><br>            <span class="hljs-comment">//修改</span><br><span class="hljs-comment">//            String sql = &quot;update dept set dname = ? ,loc = ?  where deptno = ?&quot;;</span><br><span class="hljs-comment">//            preparedStatement = connection.prepareStatement(sql);</span><br><span class="hljs-comment">//            preparedStatement.setString(1,&quot;研发三部&quot;);</span><br><span class="hljs-comment">//            preparedStatement.setString(2,&quot;北京&quot;);</span><br><span class="hljs-comment">//            preparedStatement.setInt(3,3);</span><br><span class="hljs-comment">//            int count = preparedStatement.executeUpdate();</span><br><span class="hljs-comment">//            System.out.println(count);</span><br><br><br><br><br> <span class="hljs-comment">//            查询           获取预编译的数据库操作对象</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;select ename from emp where ename like ?&quot;</span>;<br>            preparedStatement=connection.prepareStatement(sql);<br>            preparedStatement.setString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;_A%&quot;</span>);<br>            resultSet = preparedStatement.executeQuery();<br>            <span class="hljs-keyword">while</span> (resultSet.next())&#123;<br>                System.out.println(resultSet.getString(<span class="hljs-string">&quot;ename&quot;</span>));<br>            &#125;<br><br><br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放资源</span><br>            jdbcUntil.close(connection,preparedStatement,resultSet);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2022/06/29/mysql/"/>
    <url>/2022/06/29/mysql/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库-建表-增删改查"><a href="#数据库-建表-增删改查" class="headerlink" title="数据库 建表   增删改查"></a><strong>数据库 建表   增删改查</strong></h2><p><strong>创建数据库：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Create DATABASE `mybatis`;<br>use `mybatis`;<br></code></pre></td></tr></table></figure><p><strong>创建表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table `user`(<br>    `id` INT(20) not null,primary key (`id`),<br>    `name` varchar(30) default null,<br>    `pwd` varchar(30) default null<br>) engine =innodb default  charset=utf8 ;     -- engine = innodb  引擎<br></code></pre></td></tr></table></figure><p><strong>向表中插入数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into `user`(`id`,`name`,`pwd`) values<br>(1,&#x27;高国鹏&#x27;,&#x27;123456&#x27;),<br>(2,&#x27;陈茜&#x27;,&#x27;156545&#x27;),<br>(3,&#x27;刘泽鑫&#x27;,&#x27;974445&#x27;),<br>(4,&#x27;李柔&#x27;,&#x27;465512&#x27;),<br>(5,&#x27;王雨妍&#x27;,&#x27;874152&#x27;);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">--    修改用户--&gt;</span><br><span class="hljs-keyword">update</span> books <span class="hljs-keyword">set</span> bookName<span class="hljs-operator">=</span><span class="hljs-string">&#x27;JavaJava&#x27;</span> <span class="hljs-keyword">where</span> books.bookId <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">--    删除用户--&gt;</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> books <span class="hljs-keyword">where</span> bookId <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>比如转账，我向一个人转账100元，我少了100元，那个人多了100元，如果银行系统出现故障，导致我少了100，而那个人却没有增加，这就不对了，事务就是保证这两个关键操作要么都成功，要么都要失败。</p><hr><h2 id="1-事务的四大特性ACID"><a href="#1-事务的四大特性ACID" class="headerlink" title="1.事务的四大特性ACID"></a>1.事务的四大特性<strong>ACID</strong></h2><ul><li>原子性：<strong>要么全部成功，要么全部失败</strong>，事务在执行过程中发生错误，就会回到开始前的状态，就像这个事务从来没有执行过一样。</li><li>一致性：一个事务执行之前和执行之后数据库都必须处于一致性状态。</li><li>隔离性：一个事务的影响在该事务提交前对其他事物都不可见。——这通过锁来实现</li><li>持久性：只要事务成功结束，他对数据库所做的更新就必须永久保存下来。</li></ul><p>锁会带来3种问题：<strong>丢失更新、脏读、不可重复读。</strong></p><hr><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>第一种隔离级别：Read uncommitted(读未提交)</p><p>解决了更新丢失，但还是可能会出现脏读</p><p>第二种隔离级别：Read committed(读提交)</p><p>解决了更新丢失和脏读问题</p><p>第三种隔离级别：Repeatable read(可重复读取)</p><p>解决了更新丢失、脏读、不可重复读、但是还会出现幻读</p><p>第四种隔离级别：Serializable(可序化)</p><p>解决了更新丢失、脏读、不可重复读、幻读</p><p><strong>脏读</strong> ：当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p><p><strong>2.</strong> <strong>不可重复读</strong> ：在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不 可重复读。</p><p><strong>3.</strong> <strong>幻读</strong> : 第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。</p><h2 id="有多少种日志？"><a href="#有多少种日志？" class="headerlink" title="有多少种日志？"></a>有多少种日志？</h2><ul><li>错误日志  ：记录出错信息，也记录一些警告信息或者正确的信息。</li><li>查询日志  ：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。</li><li>慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</li><li>二进制日志：记录对数据库执行更改的所有操作。</li><li>中继日志</li><li>事务日志</li></ul><hr><h2 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a>数据库三大范式是什么</h2><p>第一范式：每个列都不可以再拆分。</p><p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p><p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p><ul><li>列不可再分</li><li>行可以唯一区分，主键约束（属性依赖于主键）</li><li>属性不可依赖非主属性，外键约束</li></ul><hr><h2 id="数据库三级系统模式："><a href="#数据库三级系统模式：" class="headerlink" title="数据库三级系统模式："></a>数据库三级系统模式：</h2><p>外模式、模式和内模式。</p><hr><h2 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a><strong>超键、候选键、主键、外键分别是什么？</strong></h2><ul><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h2 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a><strong>SQL 约束有哪几种？</strong></h2><ul><li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>CHECK: 用于控制字段的值范围。</li></ul><hr><h2 id="关联查询：内联接-左连接、右连接、全连接区别？-联合查询"><a href="#关联查询：内联接-左连接、右连接、全连接区别？-联合查询" class="headerlink" title="关联查询：内联接,左连接、右连接、全连接区别？ 联合查询"></a>关联查询：内联接,左连接、右连接、全连接区别？ 联合查询</h2><p>内连接：得到的两个表的乘积</p><p>隐式内连接： select * from A,B where 条件;<br>显示内连接： select * from A inner join B on 条件;</p><p>左连接（左外连接）：这个关键字左边的表为主表,会将这个表中的数据全部查询出来,如果右表中没有这条数据,则用NULL字段表示</p><p>left join  ：select * from a_table a left join b_table bon a.a_id &#x3D; b.b_id;</p><p>右连接（右外连接）：这个关键字右边的表为主,然后将符合条件的查询出来,左表中没有的字段,使用NULL进行补充</p><p>right join： select * from a_table a right outer join b_table b on a.a_id &#x3D; b.b_id;</p><p>全连接（全外连接）：可以将一条查询语句作为另外一个查询语句的条件和表,再次进行查询.  mysql不支持</p><p>联合查询（UNION与UNION ALL）：就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</p><hr><h2 id="SQL语句中常用关键词及其解释："><a href="#SQL语句中常用关键词及其解释：" class="headerlink" title="SQL语句中常用关键词及其解释："></a>SQL语句中常用关键词及其解释：</h2><p>distinct：去重</p><p>SELECT DISTINCT 列名称 FROM 表名称</p><p>limit  限制 分页  limit(0,50)  从0开始的 50条数据</p><p>and or：</p><ul><li>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</li><li>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</li></ul><p>in：IN 操作符允许我们在 WHERE 子句中规定多个值。</p><p>从表中选取姓氏为 Adams 和 Carter 的人：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM Persons<br>WHERE LastName IN (&#x27;Adams&#x27;,&#x27;Carter&#x27;)<br></code></pre></td></tr></table></figure><p>between on：会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日 ，包括两边临界值</p><p>like：_  是一个字符   %是很多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM Persons<br>WHERE City LIKE &#x27;Ne%&#x27;<br></code></pre></td></tr></table></figure><p>left join &#x2F;right join</p><p>union：用于合并两个或多个 SELECT 语句的结果集。 </p><p>union数据相同时留第一个，第二个被覆盖，如果不想被覆盖用union all</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name(s) FROM table_name1<br>UNION<br>SELECT column_name(s) FROM table_name2<br></code></pre></td></tr></table></figure><p>order by：根据指定的列对结果集进行排序。  desc 降序   asc升序</p><p>以逆字母顺序显示公司名称，并以数字顺序显示顺序号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC<br></code></pre></td></tr></table></figure><p>group by：分组，常常和函数结合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT Customer,SUM(OrderPrice) FROM Orders<br>GROUP BY Customer<br></code></pre></td></tr></table></figure><p>sql函数：avg，count，first，last，max，min，sum，</p><p>where和having：</p><ul><li>having是用来筛选组，where是用来筛选记录</li><li>一般情况下分组筛选的时候用Having，其他情况下用where。</li><li>Having是先分组在进行筛选，而where是先筛选再进行分组。</li></ul><hr><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>数据库索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息</p><p>更通俗的说，索引就相当于目录。在用新华字典时的目录，可以快速定位！</p><p>索引本质上就是一种通过减少查询需要遍历行数，加快查询性能的数据结构</p><p>常见的索引的数据结构有：B+Tree、Hash索引。</p><p>B+Tree索引：B+Tree是mysql使用最频繁的一个索引数据结构，是Innodb和Myisam存储引擎模式的索引类型。B+Tree索引在查找时需要从根节点到叶节点进行多次IO操作，在查询速度比不上Hash索引，但是更适合排序等操作。</p><p>B+Tree索引的优点：</p><ul><li>页内节点不存储内容，每次IO可以读取更多的行，大大减少磁盘I&#x2F;O读取次数</li><li>带顺序访问指针的B+Tree：B+Tree所有索引数据都存储在叶子结点上，并且增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针，这样做是为了提高区间查询效率。</li></ul><p>Hash索引：MySQL中只有Memory存储引擎支持hash索引，是Memory表的默认索引类型。hash索引把数据以hash值形式组织起来，因此查询效率非常高，可以一次定位。</p><p>hash索引的缺点：</p><ul><li>Hash索引仅能满足等值的查询，不能满足范围查询、排序。因为数据在经过Hash算法后，其大小关系就可能发生变化。</li><li>当创建组合索引时，不能只使用组合索引的部分列进行查询。因为hash索引是把多个列数据合并后再计算Hash值，所以对单独列数据计算Hash值是没有意义的。</li><li>当发生Hash碰撞时，Hash索引不能避免表数据的扫描。因为仅仅比较Hash值是不够的，需要比较实际的值以判定是否符合要求。</li></ul><hr><h2 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h2><ul><li>可以大大加快数据的检索速度</li><li>通过创建唯一索引，可以保证数据库中每一行数据的唯一性。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ul><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据的增加而增加</li><li>索引需要占物理空间</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ol><hr><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>1.普通索引：加速查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">直接创建索引：<br>CREATE INDEX index_name ON table(column(length))<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">修改表结构时创建索引：<br>ALTER TABLE table_name ADD INDEX index_name ON (column(length))<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">创建表时同时创建索引：<br>CREATE TABLE `table` (  `id` int(11) NOT NULL AUTO_INCREMENT ,  `title` char(255) CHARACTER NOT NULL ,  `content` text CHARACTER NULL ,  `time` int(10) NULL DEFAULT NULL ,  PRIMARY KEY (`id`),  INDEX index_name (title(length)) )<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">删除索引：<br>DROP INDEX index_name ON table<br></code></pre></td></tr></table></figure><p>2.唯一索引：索引列的值必须唯一，但允许有空值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">创建唯一索引：<br>CREATE UNIQUE INDEX indexName ON table(column(length))<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">修改表结构时创建索引：<br>ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">创建表时直接指定唯一索引：<br>CREATE TABLE `table` (  `id` int(11) NOT NULL AUTO_INCREMENT ,  `title` char(255) CHARACTER NOT NULL ,  `content` text CHARACTER NULL ,  `time` int(10) NULL DEFAULT NULL ,  UNIQUE indexName (title(length)) );<br></code></pre></td></tr></table></figure><p>3.主键索引：一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `table` (  `id` int(11) NOT NULL AUTO_INCREMENT ,  `title` char(255) NOT NULL ,  PRIMARY KEY (`id`) );<br></code></pre></td></tr></table></figure><p>4.组合索引：多个列值组成一个索引，专门用于组合搜索。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE `table` ADD INDEX name_city_age (name,city,age); <br></code></pre></td></tr></table></figure><p>5.全文索引：对文本的内容进行分词，进行搜索。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">创建表的适合添加全文索引：<br>CREATE TABLE `table` (  `id` int(11) NOT NULL AUTO_INCREMENT ,  `title` char(255) CHARACTER NOT NULL ,  `content` text CHARACTER NULL ,  `time` int(10) NULL DEFAULT NULL ,  PRIMARY KEY (`id`),  FULLTEXT (content) );<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">修改表结构时创建索引：<br>ALTER TABLE article ADD FULLTEXT index_content(content)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">直接创建索引：<br>CREATE FULLTEXT INDEX index_content ON article(content)<br></code></pre></td></tr></table></figure><hr><h2 id="主键、自增主键、主键索引、唯一索引区别"><a href="#主键、自增主键、主键索引、唯一索引区别" class="headerlink" title="主键、自增主键、主键索引、唯一索引区别"></a>主键、自增主键、主键索引、唯一索引区别</h2><ul><li><p>主键：唯一，非空的列，稳定，可以是聚集索引，也可以是非聚集索引</p></li><li><p>主键索引：就是主键，索引的一类</p></li><li><p>自增主键：字段类型为数字，自增，主键</p></li><li><p>唯一索引：索引列的值必须唯一，但允许有空值</p><p>主键是唯一索引，但唯一索引不一定是主键</p></li></ul><h2 id="什么导致索引失效"><a href="#什么导致索引失效" class="headerlink" title="什么导致索引失效"></a>什么导致索引失效</h2><ul><li>在 where 子句中对字段进行 null 值判断</li><li>在 where 子句中使用!&#x3D;或&lt;&gt;操作符</li><li>在 where 子句中使用 or 来连接条件</li><li>like查询是以’%’开头</li><li>在where子句中对字段进行函数操作</li><li>在 where 子句中对字段进行表达式操作<ul><li>select id from t where num&#x2F;2&#x3D;100  失效</li><li>select id from t where num&#x3D;100*2   不失效</li></ul></li><li>左连接查询或者右连接查询查询关联的字段编码格式不一样</li><li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li></ul><hr><h2 id="哪些字段适合建立索引？"><a href="#哪些字段适合建立索引？" class="headerlink" title="哪些字段适合建立索引？"></a>哪些字段适合建立索引？</h2><p>1、表的主键、外键必须有索引；<br>2、数据量超过300的表应该有索引；<br>3、经常与其他表进行连接的表，在连接字段上应该建立索引；<br>4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；<br>5、频繁进行数据操作的表，不要建立太多的索引；</p><h2 id="优化数据库的方法"><a href="#优化数据库的方法" class="headerlink" title="优化数据库的方法"></a><strong>优化数据库的方法</strong></h2><ul><li><p>优化查询语句：为避免全盘扫描，应该首先应考虑在 where 及 order by 涉及的列上建立索引，以下会导致全盘扫描而索引失效</p><ol><li>避免在 where 子句中对字段进行 null 值判断</li><li>避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符</li><li>避免在 where 子句中使用 or 来连接条件    可以用union all  连接 两个语句</li><li>in 和 not in 也要慎用，能用beteen就不要用in了</li><li>like查询是以’%’开头也会导致全盘扫描</li><li>避免在where子句中对字段进行函数操作</li><li>避免在 where 子句中对字段进行表达式操作</li></ol></li><li><p>使用连接(JOIN)来代替子查询</p></li><li><p>使用联合(UNION)来代替手动创建的临时表</p></li><li><p>选取适用的字段属性，  表中字段的宽度设得尽可能小</p></li><li><p>使用事务  BEGIN COMMIT</p><p>第一个表成功更新后，如果数据库突然出现意外情况，导致第二个表中的操作没有完成，这样就会造成数据的不完整，还可能破坏数据库中的数据，如果使用了事务，要么全成功，要么全失败，保证数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">BEGIN; <br>INSERT into salesinfo set CustomerID=14; <br>UPDATE inventory set Quantity=11 WHERE item=&#x27;book&#x27;;<br>COMMIT;<br></code></pre></td></tr></table></figure></li><li><p>锁定表  LOCK TABLE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LOCK TABLE inventory WRITE SELECT Quantity FROM inventory WHERE Item=&#x27;book&#x27;;<br><br>...<br><br>UPDATE inventory SET Quantity=11 WHERE Item=&#x27;book&#x27;;UNLOCK TABLES<br></code></pre></td></tr></table></figure></li><li><p>使用外键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE customerinfo( CustomerIDINTNOTNULL,PRIMARYKEY(CustomerID))TYPE=INNODB;<br><br> <br>CREATE TABLE salesinfo( SalesIDINTNOTNULL,CustomerIDINTNOTNULL,<br><br> <br>PRIMARYKEY(CustomerID,SalesID),<br><br> <br>FOREIGNKEY(CustomerID)REFERENCEScustomerinfo(CustomerID)ONDELETECASCADE)TYPE=INNODB;<br></code></pre></td></tr></table></figure></li><li><p>使用索引：索引应建立在那些将用于JOIN,WHERE判断和ORDER BY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。</p></li></ul><hr><h2 id="索引越多越好吗？肯定不是"><a href="#索引越多越好吗？肯定不是" class="headerlink" title="索引越多越好吗？肯定不是"></a>索引越多越好吗？肯定不是</h2><p>1、合理的建立索引能够加速数据读取效率，不合理的建立索引反而会拖慢数据库的响应速度。</p><p>​不要在选择的栏位上放置索引，这是无意义的。应该在条件选择的语句上合理的放置索引，比如where，order by。</p><p>2、索引越多，更新数据的速度越慢。</p><hr><p>存储器</p><h2 id="视图View"><a href="#视图View" class="headerlink" title="视图View"></a>视图View</h2><p>视图是从一个或者多个表（或视图）导出的表，其内容由查询定义。视图是一个虚拟表，数据库中只存储视图的定义，不存储视图对应的数据，在对视图的数据进行操作时，系统根据视图的定义去操作相应的基本表。可以说，视图是在基本表之上建立的表，它的结构和内容都来自基本表，依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。</p><p>试图优缺点：</p><p>（1）视图的优点：</p><p>简化了操作，把经常使用的数据定义为视图<br>安全性，用户只能查询和修改能看到的数据<br>逻辑上的独立性，屏蔽了真实表的结构带来的影响<br>（2）视图的缺点：</p><p>性能差，数据库必须把对视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也要把它变成一个复杂的结合体，需要花费一定的时间。</p><h2 id="视图和表的区别和联系"><a href="#视图和表的区别和联系" class="headerlink" title="视图和表的区别和联系"></a>视图和表的区别和联系</h2><p>区别：1、视图是已经编译好的sql语句。而表不是<br>      2、视图没有实际的物理记录。而表有。<br>      3、表是内容，视图是窗口<br>      4、表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改<br>      5、表是内模式，视图是外模式<br>      6、视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。<br>      7、表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。<br>      8、视图的建立和删除只影响视图本身，不影响对应的基本表。</p><p>联系：视图（view）是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。</p><h2 id="存储过程Procedure"><a href="#存储过程Procedure" class="headerlink" title="存储过程Procedure"></a>存储过程Procedure</h2><p>SQL语句需要先编译然后执行，而存储过程就是一组为了完成特定功能的SQL语句集，经过编译后存储在数据库中，<strong>用户通过制定存储过程的名字并给定参数</strong>来调用它。</p><p>存储过程的优点：</p><p>（1）标准组件式编程：存储过程创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。并且DBA可以随时对存储过程进行修改，对应用程序源代码毫无影响。<br>（2）更快的执行速度：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的，在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。<br>（3）增强SQL语言的功能和灵活性：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判杂的断和较复运算。<br>（4）减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。<br>（5）作为一种安全机制来充分利用：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。</p><h2 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h2><p>　　1、<strong>存储过程</strong>用户在数据库中<strong>完成特定操作或者任务</strong>（如插入，删除等），<strong>函数</strong>用于<strong>返回特定的数据</strong>。</p><p>　　2、存储过程声明用procedure，函数用function。</p><p>　　3、存储过程<strong>不需要返回类型</strong>，函数<strong>必须要返回类型</strong>。</p><p>　　4、存储过程可作为<strong>独立的pl-sql执行</strong>，函数<strong>不能</strong>作为独<strong>立的plsql执行</strong>，必须作为表达式的一部分。</p><p>　　5、存储过程<strong>只能通过out和in&#x2F;out来返回值</strong>，函数除了<strong>可以使用out，in&#x2F;out以外，还可以使用return返回值。</strong></p><p>　　6、sql语句（DML或SELECT)中不可用调用存储过程，而函数可以。</p><h2 id="触发器Trigger"><a href="#触发器Trigger" class="headerlink" title="触发器Trigger"></a>触发器Trigger</h2><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p><h2 id="游标Cursor"><a href="#游标Cursor" class="headerlink" title="游标Cursor"></a>游标Cursor</h2><p>游标，就是游动的标识，可以充当指针的作用，使用游标可以遍历查询数据库返回的结果集中的所有记录，但是每次只能提取一条记录，即每次只能指向并取出一行的数据，以便进行相应的操作。当你没有使用游标的时候，相当于别人一下给你所有的东西让你拿走；用了游标之后，相当于别人一件一件的给你，这时你可以先看看这个东西好不好，再自己进行选择。</p><h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><ul><li>按锁的粒度划分：表级锁、行级锁、页级锁； <ul><li>表级锁：最大粒度的锁级别，发生锁冲突的概率最高，并发度最低，但开销小，加锁快，不会出现死锁；</li><li>行级锁：最小粒度的所级别，发生锁冲突的概率最小，并发度最高，但开销大，加锁慢，会发生死锁；</li><li>页级锁：锁粒度界于表级锁和行级锁之间，对表级锁和行级锁的折中，并发度一般。开销和加锁时间也界于表锁和行锁之间，会出现死锁；</li></ul></li><li>按锁的类型划分：共享（锁S锁）、排他锁（X锁）；<ul><li>共享锁（S锁、读锁）：多个事务可以对同一数据行共享一把S锁，但只能进行读不能修改；</li><li>排它锁（X锁、写锁）：一个事务获取排它锁之后，可以对锁定范围内的数据行执行写操作，在锁定期间，其他事务不能再获取这部分数据行的锁（共享锁、排它锁），只允许获取到排它锁的事务进行更新数据。</li></ul></li><li>按锁的使用策略划分：乐观锁、悲观锁；<ul><li><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</li><li><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</li></ul></li></ul><p>死锁？ 怎么解决？</p><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p>常见的解决死锁的方法</p><p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p><p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p><p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p><p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p><h2 id="存储引擎MyISAM、InnoDB"><a href="#存储引擎MyISAM、InnoDB" class="headerlink" title="存储引擎MyISAM、InnoDB"></a>存储引擎MyISAM、InnoDB</h2><p>MYISAM:(mysql5.5之前)性能好，不支持事务处理</p><p>InnoDB：支持ACID兼容的事务功能。</p><h2 id="drop、delete、truncate"><a href="#drop、delete、truncate" class="headerlink" title="drop、delete、truncate"></a>drop、delete、truncate</h2><p>在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p><h3 id="UNION与UNION-ALL的区别？"><a href="#UNION与UNION-ALL的区别？" class="headerlink" title="UNION与UNION ALL的区别？"></a><strong>UNION与UNION ALL的区别？</strong></h3><ul><li>如果使用UNION ALL，不会合并重复的记录行</li><li>效率 UNION 高于 UNION ALL</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java虚拟机</title>
    <link href="/2022/06/29/javaxnj/"/>
    <url>/2022/06/29/javaxnj/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java多线程</title>
    <link href="/2022/06/29/javadxc/"/>
    <url>/2022/06/29/javadxc/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是多线程。-它的优点缺点-？？？"><a href="#什么是多线程。-它的优点缺点-？？？" class="headerlink" title="什么是多线程。 它的优点缺点  ？？？"></a>什么是多线程。 它的优点缺点  ？？？</h2><p>在一个程序中可以同时运行多个不同的线程来执行不同的任务。</p><p>多线程的好处：</p><p>可以提高 CPU 的利用率。在多线程程序中，<strong>一个线程必须等待的时候，CPU 可以运行其它的线程而不是等待</strong>，这样就大大提高了程序的效率。</p><p>多线程的劣势：</p><p><strong>线程需要占用内存，线程越多占用内存也越多；</strong></p><p>多线程需要协调和管理，所以需要 CPU 时间跟踪线程；</p><p>线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题。</p><h2 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h2><p>什么是线程和进程?      <strong>进程相当于一个容器  ，里面有若干个线程</strong><br>进程</p><p>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</p><p>线程</p><p>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p><p>进程与线程的区别<br>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p><p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><p><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><p><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><p><strong>内存分配</strong>：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p><p><strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p><p><strong>执行过程</strong>：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>系统在运行过程中短时间收到大量请求的情况，高并发对应的是访问请求，多线程是解决高并发的方法之一</p><h2 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h2><p>并发是指一个处理器同时处理多个任务。并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。</p><p>并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。</p><p>比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。</p><h2 id="守护线程和用户线程有什么区别呢？"><a href="#守护线程和用户线程有什么区别呢？" class="headerlink" title="守护线程和用户线程有什么区别呢？"></a>守护线程和用户线程有什么区别呢？</h2><p>守护线程和用户线程</p><p>用户 (User) 线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程<br>守护 (Daemon) 线程：运行在后台，为其他前台线程服务。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</p><ul><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不用等待守护线程执行完毕     如，后台记录操作日志，监控内存，垃圾回收等等</li></ul><h2 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h2><p>创建线程有四种方式：</p><ul><li>继承 Thread 类；</li><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>使用 Executors 工具类创建线程池</li></ul><p>Thread类  </p><ul><li>自定义线程类继承Thread类</li><li>重写run()方法，编写线程执行体</li><li>创建线程对象，调用start()方法启动线程</li></ul><p>Runnable接口  </p><ul><li>定义MyRunnable类实现Runnable接口</li><li>实现run()方法，编写线程执行体</li><li>创建线程对象，调用start()方法启动线程</li></ul><p>不建议使用Thread类 ，建议使用Runnable接口  ——》避免单继承局限性   runnable灵活方便，方便用一个对象被多个线程使用</p><p>多个线程操作同一个资源的情况下，线程不安全，数据紊乱</p><p>Callable接口（了解）  </p><ol><li>创建实现Callable接口的类</li><li>以这个类为参数创建FutureTask对象</li><li>将FutureTask作为参数创建Thread对象</li><li>调用线程对象的start()方法</li></ol><p>Executors提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。</p><h2 id="说一下-runnable-和-callable-有什么区别？"><a href="#说一下-runnable-和-callable-有什么区别？" class="headerlink" title="说一下 runnable 和 callable 有什么区别？"></a>说一下 runnable 和 callable 有什么区别？</h2><p>相同点</p><p>都是接口</p><p>都可以编写多线程程序</p><p>都采用Thread.start()启动线程</p><p>主要区别</p><p><strong>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值</strong>，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果<br><strong>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息</strong><br>注：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p><h2 id="线程的生命周期及五种基本状态？"><a href="#线程的生命周期及五种基本状态？" class="headerlink" title="线程的生命周期及五种基本状态？"></a>线程的生命周期及五种基本状态？</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy8xMi8xNS8xNjA1OWNjOTFlZThlZmIz?x-oss-process=image/format,png" alt="线程的基本状态"></p><p>初始 就绪 运行 阻塞 死亡</p><p>新建(new)：新创建了一个线程对象。</p><p>运行(runnable)：线程对象创建后，当调用线程对象的 start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。</p><p>阻塞(block)：处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。</p><p>阻塞的情况分三种：<br>(一). 等待阻塞：运行状态中的线程执行 wait()方法，JVM会把该线程放入等待队列(waitting queue)中，使本线程进入到等待阻塞状态；<br>(二). 同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态；<br>(三). 其他阻塞: 通过调用线程的 sleep()或 join()或发出了 I&#x2F;O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I&#x2F;O 处理完毕时，线程重新转入就绪状态。</p><p>死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生</p><h2 id="请说出与线程同步以及线程调度相关的方法。"><a href="#请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="请说出与线程同步以及线程调度相关的方法。"></a>请说出与线程同步以及线程调度相关的方法。</h2><p>（1） wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</p><p>（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；</p><p>（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</p><p>（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p><h2 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h2><p>两者都可以暂停线程的执行</p><p>类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。<br>是否释放锁：sleep() 不释放锁；wait() 释放锁。<br>用途不同：Wait 通常被用于线程间交互&#x2F;通信，sleep 通常被用于暂停执行。<br>用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</p><h2 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h2><p>在java中有以下3种方法可以终止正在运行的线程：</p><p>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。<br>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。<br>使用interrupt方法中断线程。</p><h2 id="如何保证多个线程同时启动？"><a href="#如何保证多个线程同时启动？" class="headerlink" title="如何保证多个线程同时启动？"></a>如何保证多个线程同时启动？</h2><p>可以用wait()，notify() 实现</p><h2 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify()和 notifyAll()有什么区别？"></a>notify()和 notifyAll()有什么区别？</h2><p>notify() 唤醒一个处于等待状态的进程</p><p>notifyAll()  唤醒同一个对象上所有调用wait()方法的线程，优先 级别 高的线程 优先 调度</p><p>notify()，notifyAll()都是要唤醒正在等待的线程，前者明确唤醒一个，后者唤醒全部。</p><p>当程序不明确知道下一个要唤醒的线程时，需要采用notifyAll()唤醒所有在wait池中的线程，让它们竞争而获取资源的执行权，但使用notifyAll()时，会出现死锁的风险，因此，如果程序中明确知道下一个要唤醒的线程时，尽可能使用notify()而非notifyAll()。</p><h2 id="线程的-run-和-start-有什么区别？"><a href="#线程的-run-和-start-有什么区别？" class="headerlink" title="线程的 run()和 start()有什么区别？"></a>线程的 run()和 start()有什么区别？</h2><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。</p><p><strong>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</strong></p><p>start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。</p><p>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p><h3 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a><strong>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</strong></h3><p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p><p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p>总结： <strong>调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p><h2 id="为什么要使用Lamda表达式？"><a href="#为什么要使用Lamda表达式？" class="headerlink" title="为什么要使用Lamda表达式？"></a>为什么要使用<strong>Lamda</strong>表达式？</h2><ul><li>避免匿名内部类定义过多</li><li>去掉了一堆没有意义的代码，只留下核心的逻辑</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>事先创建若干个可执行的线程放入一个池子中，需要的时候就从池子中获取线程不需要自行创建，使用完了也不用销毁而是放回池子中，减小了创建和销毁线程对象的开销。</p><h2 id="创建线程池有哪几种方式？"><a href="#创建线程池有哪几种方式？" class="headerlink" title="创建线程池有哪几种方式？"></a>创建线程池有哪几种方式？</h2><p>（1）newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><p>（2）newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。如果希望在服务器上使用线程池，建议使用 newFixedThreadPool方法来创建线程池，这样能获得更好的性能。</p><p>（3） newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</p><p>（4）newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p><h2 id="线程池有什么优点？"><a href="#线程池有什么优点？" class="headerlink" title="线程池有什么优点？"></a>线程池有什么优点？</h2><p>好处：</p><ul><li>提高反应速度(减少了创建新线程的时间)</li><li>降低资源消耗(重复利用线程池中线程，不需要每次都创建)</li><li>便于线程管理<ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ul></li></ul><p>线程池相关API： ExecutorService 和Executors</p><p>Executors：工具类，线程池的工厂类，用于创建并返回不同类型的线程池</p><h2 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h2><p>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。(running)<br>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。(shutdown)<br>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。(stop)<br>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。  (tidying)<br>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。(terminated)</p><h2 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit()和 execute()方法有什么区别？"></a>线程池中 submit()和 execute()方法有什么区别？</h2><p>接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务。</p><p>返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有</p><p>异常处理：submit()方便Exception处理</p><h2 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h2><p>  一个同步块同时拥有两个以上对象的锁时，就可能会发生死锁</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlQjklQjYlRTUlOEYlOTElRTclQkMlOTYlRTclQTglOEItJUU1JTlGJUJBJUU3JUExJTgwJUU3JTlGJUE1JUU4JUFGJTg2LyVFNyVCQSVCRiVFNyVBOCU4QiVFNiVBRCVCQiVFOSU5NCU4MS5wbmc" alt="线程死锁"></p><h2 id="怎么防止死锁？产生死锁的四个必要条件："><a href="#怎么防止死锁？产生死锁的四个必要条件：" class="headerlink" title="怎么防止死锁？产生死锁的四个必要条件："></a>怎么防止死锁？产生死锁的四个必要条件：</h2><p>1.<strong>互斥条件</strong>：一个资源每次只能被一个进程使用</p><p>（这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。）</p><p>2.<strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不变   </p><p>（一次性申请所有的资源。）</p><p>3.<strong>不剥夺条件</strong>：进程已获得资源，在未使用完之前，不能强行剥夺。</p><p>（占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。）</p><p>4.<strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。</p><p>（靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。）</p><p>只要想办法<strong>破其中的任意一个或多个条件就可以避免死锁发生</strong></p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： </p><p>　　1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；<br>　　2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；<br>　　3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；<br>　　4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</p><h2 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h2><p>volatile关键字和synchronized关键字的区别<br>     （1）、volatile只能作用于变量，使用范围较小。synchronized可以用在变量、方法、类、同步代码块等，使用范围比较广。<br>     （2）、volatile只能保证可见性和有序性，不能保证原子性。而可见性、有序性、原子性synchronized都可以包证。<br>     （3）、volatile不会造成线程阻塞。synchronized可能会造成线程阻塞。</p><h2 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h2><ul><li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized  是隐式锁，出了作用域自动释放</li><li>Lock只能给代码块加锁，synchronized可以给类、方法、代码块加锁</li><li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性（提供更多的子类）</li><li>优先使用顺序<ul><li>Lock&gt;同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法（在方法体之外）</li></ul></li></ul><h2 id="synchronized-（同步锁）和-ReentrantLock-（可重入锁）区别是什么？"><a href="#synchronized-（同步锁）和-ReentrantLock-（可重入锁）区别是什么？" class="headerlink" title="synchronized （同步锁）和 ReentrantLock （可重入锁）区别是什么？"></a>synchronized （同步锁）和 ReentrantLock （可重入锁）区别是什么？</h2><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作。</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁。</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li></ul><h2 id="说一下-atomic-的原理？"><a href="#说一下-atomic-的原理？" class="headerlink" title="说一下 atomic 的原理？"></a>说一下 atomic 的原理？</h2><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java集合</title>
    <link href="/2022/06/29/javajihe/"/>
    <url>/2022/06/29/javajihe/</url>
    
    <content type="html"><![CDATA[<h2 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h2><ul><li>数组是固定长度的；集合可变长度的。</li><li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li><li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li></ul><h2 id="常用的集合类有哪些？"><a href="#常用的集合类有哪些？" class="headerlink" title="常用的集合类有哪些？"></a>常用的集合类有哪些？</h2><p>Map接口和Collection接口是所有集合框架的父接口：</p><p>Collection接口的子接口包括：Set接口和List接口<br>Map接口的实现类主要有：HashMap、TreeMap、Hashtable等（ConcurrentHashMap以及Properties等）<br>Set接口的实现类主要有：HashSet、TreeSet、（LinkedHashSet等）<br>List接口的实现类主要有：ArrayList、LinkedList等（、Stack以及Vector等）</p><h2 id="List、Set、Map-之间的区别是什么？"><a href="#List、Set、Map-之间的区别是什么？" class="headerlink" title="List、Set、Map 之间的区别是什么？"></a>List、Set、Map 之间的区别是什么？</h2><p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List  。Map接口不是collection的子接口。</p><p>List：有下标，元素可以重复，可以插入多个null元素<br>Set：无序，无下标，元素不可重复，只允许存入一个null元素，必须保证元素唯一性。</p><p>Map</p><ul><li>用于存储任意键值对(Key-value)</li><li>键：无序、无下标、不允许重复（唯一）</li><li>值：无序、无下标、允许重复</li><li>从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</li></ul><h2 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a><strong>ArrayList</strong>和LinkedList区别</h2><p>ArrayList：<strong>基于动态数组</strong>，连续内存存储，<strong>适合下标访问</strong>（随机访问），扩容机制：因为<strong>数组长度固定</strong>，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动（往后复制一份，插入新元素），使用尾插法并指定初始容量可以极大提升性能、甚至超过linkedList（需要创建大量的node对象）</p><p>LinkedList：<strong>基于链表</strong>，可以存储在分散的内存中，<strong>适合做数据插入及删除操作</strong>，<strong>不适合查询</strong>：需要逐一遍历遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时都需要对list重新进行遍历，性能消耗极大。另外不要试图使用indexOf等返0回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结果为空时会遍历整个列表。</p><h2 id="HashMap和HashTable有什么区别？"><a href="#HashMap和HashTable有什么区别？" class="headerlink" title="HashMap和HashTable有什么区别？"></a>HashMap和HashTable有什么区别？</h2><p><strong>HashTable</strong>：底层数组+链表实现，无论key还是value都不能为null，线程安全，</p><p><strong>HashMap</strong>：底层数组+链表实现，可以存储null键和null值，线程不安全</p><h2 id="HashMap与HashSet的区别"><a href="#HashMap与HashSet的区别" class="headerlink" title="HashMap与HashSet的区别"></a>HashMap与HashSet的区别</h2><p><img src="C:\Users\高国鹏\AppData\Roaming\Typora\typora-user-images\image-20210901203618244.png" alt="image-20210901203618244"></p><h2 id="19-Collection-和-Collections-有什么区别？"><a href="#19-Collection-和-Collections-有什么区别？" class="headerlink" title="19.Collection 和 Collections 有什么区别？"></a>19.Collection 和 Collections 有什么区别？</h2><p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。<br>Collections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p><h2 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h2><p>对于在Map中<strong>插入、删除和定位</strong>元素这类操作，<strong>HashMap是最好的选择</strong>。然而，假如你需要对<strong>一个有序的key集合进行遍历</strong>，<strong>TreeMap</strong>是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p><h2 id="说一下-HashMap-的实现原理？"><a href="#说一下-HashMap-的实现原理？" class="headerlink" title="说一下 HashMap 的实现原理？"></a>说一下 HashMap 的实现原理？</h2><p>HashMap概述： <strong>HashMap是基于哈希表的Map接口的非同步实现</strong>。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p>HashMap 基于 Hash 算法实现的</p><p>当我们往HashMap中</p><p><strong>put元素时</strong>，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标<br><strong>存储时，</strong>如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中<br><strong>获取时</strong>，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p><h2 id="HashMap是如何解决hash冲突的问题"><a href="#HashMap是如何解决hash冲突的问题" class="headerlink" title="HashMap是如何解决hash冲突的问题"></a>HashMap是如何解决hash冲突的问题</h2><p>核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p><h2 id="24-说一下-HashSet-的实现原理？"><a href="#24-说一下-HashSet-的实现原理？" class="headerlink" title="24.说一下 HashSet 的实现原理？"></a>24.说一下 HashSet 的实现原理？</h2><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT（ present），因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h2 id="27-ArrayList-和-Vector-的区别是什么？"><a href="#27-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="27.ArrayList 和 Vector 的区别是什么？"></a>27.ArrayList 和 Vector 的区别是什么？</h2><p><strong>ArrayList【重点】</strong></p><ul><li>数组结构实现，查询快，增删慢</li><li>运行效率快，线程不安全</li></ul><p><strong>Vector</strong></p><ul><li>数组结构实现，查询快，增删慢</li><li>运行效率慢，线程安全</li></ul><h2 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h2><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p><h2 id="如何实现-Array-和-List-之间的转换？"><a href="#如何实现-Array-和-List-之间的转换？" class="headerlink" title="如何实现 Array 和 List 之间的转换？"></a>如何实现 Array 和 List 之间的转换？</h2><ul><li>Array 转 List： Arrays. asList(array) ；</li><li>List 转 Array：List 的 toArray() 方法。</li></ul><h2 id="30-哪些集合类是线程安全的？"><a href="#30-哪些集合类是线程安全的？" class="headerlink" title="30.哪些集合类是线程安全的？"></a>30.哪些集合类是线程安全的？</h2><p>vector：就比arraylist多了个同步化机制（<strong>线程安全</strong>），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。<br>statck：堆栈类，先进后出。<br>hashtable：就比hashmap多了个线程安全。<br>enumeration：枚举，相当于迭代器。</p><h2 id="31-迭代器-Iterator-是什么？"><a href="#31-迭代器-Iterator-是什么？" class="headerlink" title="31.迭代器 Iterator 是什么？"></a>31.迭代器 Iterator 是什么？</h2><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h2 id="32-Iterator-怎么使用？有什么特点？"><a href="#32-Iterator-怎么使用？有什么特点？" class="headerlink" title="32.Iterator 怎么使用？有什么特点？"></a>32.Iterator 怎么使用？有什么特点？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Iterator&lt;String&gt; it = list. iterator();<br><span class="hljs-keyword">while</span>(it. hasNext())&#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> it. next();<br>  System. out. println(obj);<br><br></code></pre></td></tr></table></figure><p>Iterator 的特点是只能<strong>单向遍历，但是更加安全</strong>，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h2 id="33-Iterator-和-ListIterator-有什么区别？"><a href="#33-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="33.Iterator 和 ListIterator 有什么区别？."></a>33.Iterator 和 ListIterator 有什么区别？.</h2><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。<br>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p><h2 id="34-怎么确保一个集合不能被修改？"><a href="#34-怎么确保一个集合不能被修改？" class="headerlink" title="34.怎么确保一个集合不能被修改？"></a>34.怎么确保一个集合不能被修改？</h2><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p><p><img src="C:\Users\高国鹏\AppData\Roaming\Typora\typora-user-images\image-20210901090538820.png" alt="image-20210901090538820"></p><p><strong>Collection</strong></p><p><img src="C:\Users\高国鹏\AppData\Roaming\Typora\typora-user-images\image-20210901091146003.png" alt="image-20210901091146003"></p><p>iterator迭代器：专门用来遍历集合的一种方式</p><p><img src="C:\Users\高国鹏\AppData\Roaming\Typora\typora-user-images\image-20210901093158973.png" alt="image-20210901093158973"></p><p>hasNext()有没有下一个元素</p><p>next()获取下一个元素</p><p>remove()删除当前元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> it.next();<br>System.out.println(o);<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>List集合</strong></p><p><img src="C:\Users\高国鹏\AppData\Roaming\Typora\typora-user-images\image-20210901100826292.png" alt="image-20210901100826292"></p><p><strong>Map</strong></p><p><img src="C:\Users\高国鹏\AppData\Roaming\Typora\typora-user-images\image-20210901164956176.png" alt="image-20210901164956176"></p><p><strong>Map接口特点：</strong></p><ul><li>用于存储任意键值对(Key-value)</li><li>键：无序、无下标、不允许重复（唯一）</li><li>值：无序、无下标、允许重复</li></ul><p><strong>方法：</strong></p><ul><li>V put(K key,V value)    将对象存入到集合中，关联键值。key重复则覆盖原值i”</li><li>Object get(Object key) 根据键获取对应的值</li><li>Set<K>  返回所有key</li><li>Collection<V> values()  返回包含所有值的Collection集合</li><li>Set&lt;Map.Entry&lt;K,V&gt;&gt; 键值匹配的Set集合</li></ul><p><strong>HashMap【重点】</strong></p><p>线程不安全，运行效率快；允许null作为key或是value</p><p><strong>Hashtable</strong></p><p>线程安全 运行效率慢  不允许null作为key或是value</p><p><strong>Properties：</strong></p><p>hashtable的子类，要求key和value都是String。通常用于配置文件的读取</p><p><strong>TreeMap：</strong></p><p>实现了SortedMap接口（是Map的子接口），可以对key自动排序</p><p><strong>泛型</strong></p><p>泛型类 泛型接口 泛型方法 &lt; T &gt; T称为类型占位符，表示一种引用类型</p><p>好处:提高代码重用性。 防止类型转换异常，提高代码的安全性  （传入参数有各种类型的时候会用到）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java面试题</title>
    <link href="/2022/06/29/java/"/>
    <url>/2022/06/29/java/</url>
    
    <content type="html"><![CDATA[<h2 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1.JDK 和 JRE 有什么区别？"></a>1.JDK 和 JRE 有什么区别？</h2><p>jdk包含了jre</p><p>jdk是开发工具包，提供了运行环境</p><p>jre是运行环境</p><h2 id="2-x3D-x3D-和equals的区别是什么？"><a href="#2-x3D-x3D-和equals的区别是什么？" class="headerlink" title="2.&#x3D;&#x3D;和equals的区别是什么？"></a>2.&#x3D;&#x3D;和equals的区别是什么？</h2><p>&#x3D;&#x3D;是关系运算符，equals()是方法，结果都返回布尔值。</p><p>Object中的&#x3D;&#x3D;和equals比较的都是地址，作用相同。</p><p>&#x3D;&#x3D;：基本类型中比较值是否相等，引用类型中比较内存地址值是否相等</p><p>equals：一般已经重写了equals方法，比较的是内容。</p><h2 id="3-如何将字符串反转？"><a href="#3-如何将字符串反转？" class="headerlink" title="3.如何将字符串反转？"></a>3.如何将字符串反转？</h2><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><h2 id="4-hashCode-与-equals-重要-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？hashCode和equals方法的关系"><a href="#4-hashCode-与-equals-重要-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？hashCode和equals方法的关系" class="headerlink" title="4.hashCode 与 equals (重要)          ||        两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？hashCode和equals方法的关系"></a>4.hashCode 与 equals (重要)          ||        两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？hashCode和equals方法的关系</h2><p>hashCode() 的作用是获取哈希码，这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p>如果两个对象相等，则hashcode一定也是相同的，而且对两个对象分别调用equals方法都返回true </p><p>两个对象有相同的hashcode值，它们也不一定是相等的</p><h2 id="5-final"><a href="#5-final" class="headerlink" title="5.final"></a>5.final</h2><p>final 最终的，修饰类，方法和变量，final修饰的类不能被继承，修饰的方法不能重写，但是能重载。修饰的成员变量必须初始化，赋值后不能重新赋值。</p><h2 id="6-八大基本数据类型、转换规则"><a href="#6-八大基本数据类型、转换规则" class="headerlink" title="6.八大基本数据类型、转换规则"></a>6.八大基本数据类型、转换规则</h2><p>byte short int long float double char boolean</p><p>低级可以自动向高级转换、高级需要强制转换称为低级，但可能会丢失精度。</p><h2 id="7-抽象类和接口有什么区别"><a href="#7-抽象类和接口有什么区别" class="headerlink" title="7.抽象类和接口有什么区别"></a>7.抽象类和接口有什么区别</h2><p>抽象类可以有构造方法，接口不能有构造方法</p><p>抽象类可以有普通成员变量，接口中没有普通成员变量</p><p>抽象类可以包含非抽象方法，接口中都是抽象方法</p><p>抽象类中抽象方法访问权限可以是public，protected，default，接口中默认是 public abstract</p><h2 id="9-普通类和抽象类有什么区别？"><a href="#9-普通类和抽象类有什么区别？" class="headerlink" title="9.普通类和抽象类有什么区别？"></a>9.普通类和抽象类有什么区别？</h2><p>抽象类不能被实例化</p><p>抽象类可以有抽象方法，只需声明，无需实现</p><p>抽象类的子类必须实现抽象类中的所有抽象方法、否则这个子类也是抽象类</p><p>抽象方法不能被声明为静态  不能被private、final修饰    (为什么不能被final修饰?因为抽象类是被用于继承的，final修饰代表不可修改，不可继承)</p><h2 id="8-Java访问修饰符有哪些？权限的区别？"><a href="#8-Java访问修饰符有哪些？权限的区别？" class="headerlink" title="8.Java访问修饰符有哪些？权限的区别？"></a>8.Java访问修饰符有哪些？权限的区别？</h2><p>public当前类可以访问、同一个包下可以访问、子孙类可以访问、其他包可以访问</p><p>protected 当前类可以访问、同一个包下可以访问、子孙类可以访问、其他包不可以访问</p><p>default当前类可以访问、同一个包可以访问、子孙类不可以访问、其他包不可以访问</p><p>private当前类可以访问、同一个包不可以访问、子孙类不可以访问、其他包不可以访问</p><h2 id="11-方法重载和重写是什么，有什么区别？"><a href="#11-方法重载和重写是什么，有什么区别？" class="headerlink" title="11.方法重载和重写是什么，有什么区别？"></a>11.方法重载和重写是什么，有什么区别？</h2><p>重写发生在子类继承父类，参数列表相同，方法名相同   访问权限只能从小范围到大范围</p><p>重载 一个类里 同名不同参数</p><h2 id="12-instanceof关键字的作用是什么？"><a href="#12-instanceof关键字的作用是什么？" class="headerlink" title="12.instanceof关键字的作用是什么？"></a>12.instanceof关键字的作用是什么？</h2><p>用来在运行时判断对象是否是指定 类及其父类的一个实例</p><p>比较的是对象，不能比较基本类型</p><h2 id="13-类和对象的关系"><a href="#13-类和对象的关系" class="headerlink" title="13.类和对象的关系"></a>13.类和对象的关系</h2><p>Emp  emp &#x3D; new Emp();</p><p>.类是对象的抽象，对象是类的具体实例</p><p>类是抽象的，不占内存，对象是具体的，占内存</p><h2 id="14-static关键字的作用是什么？"><a href="#14-static关键字的作用是什么？" class="headerlink" title="14.static关键字的作用是什么？"></a>14.static关键字的作用是什么？</h2><p>static可以修饰成员变量，方法，代码块和内部类</p><p>可以通过创建的对象名.属性名  和类名.属性名 两种方式访问</p><p>static代码块 在类被第一次加载时执行静态代码块，且只被执行一次。</p><h2 id="15-abstract关键字的作用？"><a href="#15-abstract关键字的作用？" class="headerlink" title="15.abstract关键字的作用？"></a>15.abstract关键字的作用？</h2><p>可以修饰类和方法、不能修饰属性和构造方法</p><p>abstract修饰的类 是抽象类，需要被继承</p><p>abstract修饰的方法是抽象方法，需要子类被重写</p><h2 id="16-this和super关键字的作用"><a href="#16-this和super关键字的作用" class="headerlink" title="16.this和super关键字的作用"></a>16.this和super关键字的作用</h2><p>this <strong>对象内部指代自身的引用</strong>，可以理解为指向对象本身的一个指针</p><p>super代表对<strong>当前对象的直接父类对象的引用</strong>，可以理解为是指向自己父类对象的一个指针</p><h2 id="17-java数组有什么特征？创建数组"><a href="#17-java数组有什么特征？创建数组" class="headerlink" title="17.java数组有什么特征？创建数组"></a>17.java数组有什么特征？<strong>创建数组</strong></h2><p>数组下标从0开始</p><p>每个数组元素都有默认值，基本类型的默认值为0 0.0 false 引用类型的默认值为null</p><p>数组的类型只能是一个，而且固定，在声明时确定，数组的长度一旦确定，无法改变。</p><p> int[] 数组名 &#x3D;{数组内的参数，用逗号隔开}</p><p>int [] 数组名 &#x3D; new int[数组长度];这里要注意使用适当长度的数组</p><p>int 数组名[] &#x3D; new int[]{数组内的参数，用逗号隔开}; </p><h2 id="18-什么是包装类，为什么要有包装类，基本数据类型怎么和包装类进行转换"><a href="#18-什么是包装类，为什么要有包装类，基本数据类型怎么和包装类进行转换" class="headerlink" title="18.什么是包装类，为什么要有包装类，基本数据类型怎么和包装类进行转换"></a>18.什么是包装类，为什么要有包装类，基本数据类型怎么和包装类进行转换</h2><p>Byte Boolean Short Character Integer Long Float Double</p><p>提供很多方法如 parseInt   toHexString</p><p>基本—-》包装 ： new 包装类</p><p>包装——》基本  xxxValue()</p><h2 id="19-java中操作字符串都有哪些类？分别有什么区别？-String、StringBuffer、StringBuilder"><a href="#19-java中操作字符串都有哪些类？分别有什么区别？-String、StringBuffer、StringBuilder" class="headerlink" title="19.java中操作字符串都有哪些类？分别有什么区别？             String、StringBuffer、StringBuilder"></a>19.java中操作字符串都有哪些类？分别有什么区别？             <strong>String、</strong>StringBuffer<strong>、</strong>StringBuilder</h2><p>String是final修饰的，不可变，每次操作都会产生新的String对象</p><p>StringBuffer和StringBuilder都是在原对象上操作</p><p>StringBuffer是线程安全的  多线程操作字符串缓冲区下操作大量数据  |||||||||||    StringBuilder线程不安全的  单线程操作字符串缓冲区下操作大量数据</p><p>性能：StringBuilder &gt; StringBuffer &gt; String</p><h2 id="20-String-类的常用方法都有哪些？"><a href="#20-String-类的常用方法都有哪些？" class="headerlink" title="20.String 类的常用方法都有哪些？"></a>20.String 类的常用方法都有哪些？</h2><p>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字母。<br>substring()：截取字符串。<br>equals()：字符串比较。</p><h2 id="21-说一说你对面向过程和面向对象的理解"><a href="#21-说一说你对面向过程和面向对象的理解" class="headerlink" title="21.说一说你对面向过程和面向对象的理解"></a>21.说一说你对面向过程和面向对象的理解</h2><p>面向对象相对于面向过程来说，是两种不同处理问题的角度，</p><p>面向过程更注重事情的每一个步骤和顺序，面向对象更注重事情有哪些对象，以及对象都需要做什么</p><p>比如洗衣机和洗衣服</p><p>面向过程会将任务拆解为一系列的步骤：打开洗衣机—–》放衣服—–》放洗衣液—–》清洗—–》烘干</p><p>而面向对象会拆分为人和洗衣机：人：需要 打开洗衣机 放衣服 放洗衣液</p><p>​洗衣机： 清洗  烘干</p><p>面向过程比较直接高效，面向对象更易于复用、扩展和维护。</p><p>例子：洗衣机和洗衣服</p><h2 id="22-面向对象的三大特性-封装-继承-多态"><a href="#22-面向对象的三大特性-封装-继承-多态" class="headerlink" title="22.面向对象的三大特性  封装  继承  多态"></a>22.面向对象的三大特性  封装  继承  多态</h2><p>封装：尽可能隐藏对象的内部实现细节，控制对象的修改及访问的权限：就是<strong>属性私有化，增强数据安全性</strong></p><p>继承：子类继承父类，子类可以重写父类中的方法，可以继承父类的属性，私有的属性和方法不可以继承</p><p>多态：多态是同一个行为具有多个不同表现形式或形态的能力。</p><p>​          指允许不同类的对象对同一消息做出的响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式。</p><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p><h2 id="23-向上转型"><a href="#23-向上转型" class="headerlink" title="23.向上转型"></a>23.向上转型</h2><p>格式：父类名称 对象名 &#x3D; new 子类名称();       </p><p>含义：右侧创建一个子类对象，把它当作父类来使用。      </p><p>注意：向上转型一定是安全的。      </p><p>缺点：一旦向上转型，子类中原本特有的方法就不能再被调用了。</p><h2 id="24-amp-和-amp-amp-的区别"><a href="#24-amp-和-amp-amp-的区别" class="headerlink" title="24.&amp;和&amp;&amp;的区别"></a>24.&amp;和&amp;&amp;的区别</h2><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p><h2 id="25-反射"><a href="#25-反射" class="headerlink" title="25.反射"></a>25.反射</h2><p>什么是反射机制？<br><strong>JAVA反射机制是在运行状态中，</strong></p><p><strong>对于任意一个类，都能够知道这个类的所有属性和方法；</strong></p><p><strong>对于任意一个对象，都能够调用它的任意一个方法和属性；</strong></p><p>这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p>静态编译和动态编译</p><p><strong>静态编译：</strong>在编译时确定类型，绑定对象<br><strong>动态编译：</strong>运行时确定类型，绑定对象<br><strong>反射机制优缺点</strong><br>优点： 运行期类型的判断，动态加载类，提高代码灵活度。<br>缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。<br>反射机制的应用场景有哪些？<br>反射是框架设计的灵魂。</p><p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p><h2 id="26-Java获取反射的三种方法"><a href="#26-Java获取反射的三种方法" class="headerlink" title="26.Java获取反射的三种方法"></a>26.Java获取反射的三种方法</h2><p>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p><h2 id="27-java序列化？"><a href="#27-java序列化？" class="headerlink" title="27.java序列化？"></a>27.java序列化？</h2><p><strong>将 Java 对象转换成字节流的过程。</strong></p><p>反序列化：将字节流转换成 Java 对象的过程。</p><p>当 Java 对象需要在网络上传输 或者 持久化存储到文件中时，就需要对 Java 对象进行序列化处理。</p><p>注意事项：</p><p>某个类可以被序列化，则其子类也可以被序列化<br>声明为 static 和 transient 的成员变量，不能被序列化。static 成员变量是描述类级别的属性，transient 表示临时数据<br>反序列化读取序列化对象的顺序要保持一致</p><span id="more"></span>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第一个模块</title>
    <link href="/2022/06/29/my-first-post/"/>
    <url>/2022/06/29/my-first-post/</url>
    
    <content type="html"><![CDATA[<p>1.这是我创建的第一个模块内容</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/28/hello-world/"/>
    <url>/2022/06/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
